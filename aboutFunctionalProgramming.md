# 함수형 관점으로 생각하기

함수형(functional)은 일급함수와 관련이 있으며 때로는 객체 변화를 제한하는 것이 함수형과 밀접한 관련을 갖는다.

*** 함수형을 적용하면 어떤 점이 좋을까? ***


### 시스템 구현과 유지보수

누군가 우리에게 이미 구현되어 있지만 실제 경험해본 적은 없는 대규모 소프트웨어 시스템 업그레이드 관리를 요청했다고 가정하자.

이 요청을 받아들일 것인가?

'먼저 프로그램 내에 synchronized가 없다면 시스템의 구조를 자세히 검토해보라'-자바 개발자사이의 풍문이 떠돈다.

지금까지는 자바8의 스트림을 이용하면 잠금(locking)문제를 신경 쓰지 않을 수 있었다. 단, 자바8의 스트림을 이용하려면 상태 없는 동작이어야 한다는 조건을 만족해야 한다(즉, 스트림 처리 파이프라인의 함수는 다른 누군가가 변수의 값을 바꿀 수 있는 상태에 있는 변수-외부변수-를 사용하지 않는다.)
또한 쉽게 유지보수할 수 있으려면 프로그램이 어떤 모습이어야 할까? 프로그램이 시스템의 구조를 이해하기 쉽게 클래스 계층으로 반영한다면 좋을 것이다.
결합도(coupling)와 응집도(cohesion)라는 소프트웨어 엔지니어링 도구로 프로그램 구조를 평가할 수 있다.

그러나 실질적으로 많은 프로그래머가 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게 된다.
코드 크래시는 예상하지 못한 변숫값 때문에 발생할 수 있다.
왜 그리고 어떻게 변숫값이 바뀐 걸까?
유지보수 중 이런 일이 얼마나 자주 일어나는지 생각해보라.
함수형 프로그래밍이 제공하는 부작용 없음과 불변성이라는 개념이 이 문제를 해결하는 데 도움을 준다.

#### 공유된 가변 데이터

변수가 예상하지 못한 값을 갖는 이유는? 시스템의 여러 곳에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다. (DB처럼, 따라서 locking이 중요하다. 하지만 locking은 병목현상을 발생시킬 수 있다.)
리스트를 참조하는 여러 클래스가 있다고 가정하자.
리스트의 소유자는 어느 클래스인가?
이들 중 하나의 클래스가 리스트를 갱신하면 어떻게 될까?
다른 클래스는 리스트가 갱신되었다는 사실을 알고 있을까?
다른 클래스에 리스트가 갱신되었음을 어떻게 알려줄 수 있을까?
리스트 갱신 사실을 알리는 것이 좋을까 아니면 안전하게 리스트 사본을 만드는 것이 나을까?

이처럼 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.

어떤 자료구조도 바꾸지 않는 시스템이 있다고 가정하자.
예상하지 못하게 자료구조의 값이 바뀔 일이 없으니 얼마나 유지보수하기 쉽겠는가?!
자신을 포함하는 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수(pure)메서드 또는 부작용 없는(side-effect free)메서드 라고 부른다.

구체적으로 부작용은 무엇일까? 함수 내에 포함되지 못한 기능을 부작용이라고 한다.
- 자료구조를 고치거나 필드에 값을 할당(setter 메서드 같은 생성자 이외의 초기화 동작)
- 예외 발생
- 파일에 쓰기 등의 I/O 동작 수행

이러한 부작용은 불변객체를 이용해서 없앨 수도 있다. 불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않는다. 즉, 인스턴스화한 불변 객체의 상태는 결코 예상하지 못한 상태로 바뀌지 않는다.(그러면 해당 객체의 변경된 값을 사용하려면 항상 복사본을 사용해서 값을 사용해야 하는 건가?)
따라서 불변 객체는 복사하지 않고 공유할 수 있으며, 객체의 상태를 바꿀 수 없으므로 스레드 안전성을 제공한다.

어떤 사람은 실제 시스템에서 부작용을 없앤다는 것이 현실적으로 가능한지 의아해 할 수 있다. 
이 책을 읽고 부작용을 없앨 수 있다는 사실을 확신하기 바란다.
부작용 없는 시스템 컴포넌트에서는 메서드가 서로 간섭하는 일이 없으므로 잠금을 사용하지 않고도(병목없이) 멀티코어 병렬성을 사용할 수 있다. 또한 프로그램의 어떤 부분이 독립적인지 바로 이해할 수 있다.

부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래되었다.
함수형 프로그래밍의 기반을 이루는 개념인 선언형 프로그래밍을 살펴보자.(스트림에서 사용했던 내용인 듯)


#### 선언형 프로그래밍

프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있다. '이 일을 먼저하고, 그다음에 저 값을 갱신하고, 그다음에...' 처럼 작업을 어떻게 수행할 것인지에 집중하는 방법이 있다.
이처럼 '어떻게'에 집중하는 프로그래밍 형식은 고전의 객체지향 프로그래밍에서 이용하는 방식이다.
때로는 이를 명령형 프로그래밍이라고 부르기도 하는데 다음 코드에서 보여주는 것처럼 (할당, 조건문, 분기문, 루프 등) 명령어가 컴퓨터의 저수준 언어와 비슷하게 생겼기 때문이다.

```java
Transaction mostExpensive = transaction.get(0);
if(mostExpensive == null)
	throw new IllegalArgumentException("Empty list of transactions")

for (Transaction t: transactions.subList(1, transactions.size())) {
	if (t.getValue() > mostException.getValue()) {
		mostExpensive = t;
	}
}
```

'어떻게'가 아닌 '무엇을'에 집중하는 방식도 있다.
이전 스트림 API로 다음과 같은 질의를 만들 수 있었다.

```java
Optional<Transaction> mostExpensive = 
	transactions.stream()
		.max(comparing(Transaction::getValue));
```

질의문 구현 방법은 라이브러리가 결정한다. 이와 같은 구현 방식을 *** 내부 반복*** 이라고 한다.
질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다.

이처럼 '무엇을'에 집중하는 방식을 선언형 프로그래밍이라고 부른다. 
선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성한 것인지 등의 규칙을 정한다. 문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점이다.


#### 왜 함수형 프로그래밍인가?

함수형은 선언형을 따르는 대표적인 방식이며, 부작용이 없는 계산을 지향한다. 
위 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.

람다 표현식을 통해서 작업을 조합하거나 동작을 전달하는 등의 언어기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현하는데 많은 도움을 준다.
스트림으론 여러 연산을 연결해서 복잡한 질의를 표현할 수 있었다.

실제로 함수형 프로그래밍을 사용하고 자바8의 새로운 기능과 연결하려면 먼저 함수형 프로그래밍을 제대로 정의하고 자바로 어떻게 구현하는지 살펴봐야 한다. 함수형 프로그래밍을 이용하면 부작용이 없는 복잡하고 어려운 기능을 수행하는 프로그램을 구현할 수 있다.


### 함수형 프로그래밍이란 무엇인가?

'함수를 이용하는 프로그래밍이다'라고 답할 수 있다. 그럼 '함수란 무엇인가?'라는 질문이 다시 꼬리를 문다.

int와 double을 인수로 받아서 double을 반환하는 메서드가 있는데 이 메서드는 자신이 호출된 횟수로 가변 변수를 갱신하는 부작용을 포함하고 있다.

함수형 프로그래밍에서 함수란 수학적인 함수와 같다. 즉, 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 부작용이 없어야 한다. 
(side-effect없이 입력에 따른 출력만 수행, 동일한 입력에 대해서 동일한 출력을 반환, 솔직히 자바를 통한 복잡한 프로그래밍을 해보지 않아서 함수형 프로그래밍의 필요성을 충분히 인지하지 못한 상태로 이 책을 읽는 것에 대해서 아쉬움이 있다.)

자바와 같은 언어에서는 바로 수학적인 함수냐 아니냐가 메서드와 함수를 구분하는 핵심이다.
(log, sin 등의 수학적 함수는 절대 부작용을 포함하지 않을 것이다.)

***함수형***프로그래밍은 지금까지의 프로그래밍과는 사뭇 다른 모습일 것이다.
함수형 프로그래밍에선 함수 그리고 if-then-else등의 수학적 표현만 사용해야 하는가? 
아니면 시스템의 다른 부분에 ***영향을 미치지 않는다면*** 내부적으로 함수형이 아닌 기능도 사용할 수 있을까?
즉, 내부적으론 부작용이 발생하지만 호출자가 이를 알아차리지 못한다면 실제로 부작용이 발생한 것이라고 말할 수 있을까? 호출자에게 아무 영향을 미치지 않는다면 호출자는 내부적인 부작용을 파악하거나 신경쓸 필요가 없다.
결론적으로 '함수 그리고 if-then-else 등의 수학적 표현만 사용'하는 방식을 순수 함수형 프로그래밍이라고 하며 '시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용'하는 방식을 함수형 프로그래밍이라 한다.


#### 함수형 자바

실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 예를 들어 자바의 I/O 모델 자체에는 부작용 메서드가 포함된다(Scanner.nextLine을 호출하면 파일의 행을 소비한다. 즉, Scanner.nextLine을 두 번 호출하면 다른 결과가 반환될 가능성이 있다.)
하지만 시스템의 컴포넌트가 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수 있다.
자바에선 순수 함수형이 아니라 ***함수형 프로그래밍***을 구현할 것이다.
실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 함수형을 달성할 수 있다.
예를 들어 부작용을 일으키는 어떤 함수나 메서드가 있는데, 다만 진입할 때 어떤 필드의 값을 증가시켰다가 빠져나올 때 필드의 값을 돌려놓는다고 가정하자. 단일 스레드로 실행되는 프로그램의 입장에서는 이 메서드가 아무 부작용을 일으키지 않으므로 이 메서드는 함수형이라 간주할 수 있다. 하지만 다른 스레드가 필드의 값을 확인한다든가 아니면 동시에 이 메서드를 호출하는 상황이 발생할 수 있다면 이 메서드는 함수형이 아니다. 메서드의 바디를 잠금으로써 이 문제를 해결할 수 있으며 따라서 이 메서드는 함수형이라고 할 수 있다.
하지만 이런 식의 해결은 멀티코어 프로세서에서 메서드를 병렬로 호출할 수 없게 된다.
결국 부작용은 사라지지만 실행속도가 느려진다.

함수나 메서드는 ***지역 변수만***을 변경해야 함수형이라고 할 수 있다.
그리고 함수나 메서드에서 참조하는 객체가 있다면 불변 객체여야 한다.
예외적으로 메서드 내에서 생성한 객체의 필드는 갱신할 수 있다.
단 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 하고, 다음에 메서드를 다시 호출할 때 영향을 미치면 안된다.

함수형이라고 말할 수 있으려면 이 외에도 다른 조건을 만족해야 한다. 함수형이라면 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.
예외가 발생하면 return으로 결과 반환이 안되기 때문이다.
이러한 제약은 Optional을 통해 해결할 수 있다.
예외 없이도 결과값으로 연산을 성공적으로 수행했는지 아니면 요청된 연산을 성공적으로 수행하지 못했는지 확인할 수 있다.
즉, 호출자는 메서드 호출결과로 빈 Optional이 반환되는지 확인해야 한다.
이는 상당히 귀찮은 작업같다.
하지만 모든 코드가 Optional을 사용하도록 반드시 고쳐야 하는 것은 아니다.
함수형 프로그래밍과 순수 함수형 프로그래밍의 장단점을 실용적으로 고려해서 다른 컴포넌트에 영향을 미치지 않도록 지역적으로만 예외를 사용하는 방법도 고려할 수 있다.

함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.(즉, 먼저 자료구조를 복사한다든가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야 한다.)
이와 같은 설명을 주석으로 표현하거나 마커 어노테이션으로 메서드를 정의할 수 있다.
마커 어노테이션을 사용했다면 4장부터 7장까지 살벼본 Stream.map같은 병렬 스트림 처리 연산에 전달할 때 이와 같은 제약이 있는지 쉽게 확인할 수 있다.

우리가 만든 함수형 코드에서는 일종의 로그 파일로 디버깅 정보를 출력하도록 구현하는 것이 좋다.
물론 이처럼 디버깅 정보를 출력하는 것은 함수형 규칙에 위배되지만 로그 출력을 제외하고는 함수형 프로그래밍의 장점을 문제없이 누릴 수 있다.

#### 참조 투명성

'부작용을 감춰야 한다'라는 제약은 ***참조 투명성*** 개념으로 귀결된다. 즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.
("raoul".replace('r', 'R')이란 코드는 항상 같은 결과가 나오므로 String.replace는 참조적으로 투명하다. String.replace는 return this가 아니라 처리 후 새로운 String을 반환함.)

다시 말해, 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다.
따라서 Random.nextInt는 매번 다른 값이 호출되므로 함수형이 될 수 없다.
마찬가지로 Scanner객체로 사용자의 키보드 입력을 받는다면 참조 투명성을 위배한다.
nextLine 메서드를 호출했을 때 매번 다른 결과가 나올 수 있기 때문이다.
하지만 두 개의 final int변수를 더하는 연산에서는 두 변수를 바꿀 수 없으므로 이 연산은 항상 같은 결과를 생성한다.

참조 투명성은 프로그램 이해에 큰 도움을 준다. 또한 참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 기억화 또는 캐싱을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다. 이 기능이 중요하니 추후 설명한다.

자바에는 참조 투명성과 관련한 작은 문제가 있다. List를 반환하는 메서드를 두 번 호출한다고 가정하자. 두 번의 호출 결과로 같은 요소를 포함하지만 서로 다른 메모리 공간에 생성된 리스트를 참조할 것이다.
(각 List는 필드들은 같지만 메모리 주소가 다른 객체이다.)
결과 리스트가 가변 객체라면 (반환된 두 리스트가 같은 객체라 할 수 없으므로) 리스트를 반환하는 메서드는 참조적으로 투명한 메서드가 아니라는 결론이 나온다. 결과 리스트를 (불변의) 순수값으로 사용할 것이라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는 참조적으로 투명한 것으로 간주할 수 있다.
일반적으로 함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다. 

#### 객체지향 프로그래밍과 함수형 프로그래밍

먼저 함수형 프로그래밍과 기존의 익스트림 객체지향 프로그래밍을 비교하자.
사실 자바8은 함수형 프로그래밍을 익스트림 객체지향 프로그래밍의 일종으로 간주한다.
대부분의 자바 프로그래머는 무의식적으로 함수형 프로그래밍의 일부 기능과 익스트림 객체지향의 일부 기능을 사용할 것이다.
1장에서 설명한 것처럼(멀티코어 등의) 하드웨어 변경과 (데이터 베이스의 질의와 비슷한 방식으로 데이터를 조작하는 등의) 프로그래머의 기대치 때문에 결국 자바 소프트웨어 엔지니어의 프로그래밍 형식이 좀 더 함수형으로 다가갈 것이다.

|익스트림 객체지향 <-----------> 함수형 프로그래밍|
위 스펙트럼에서 중간에서 프로그래밍 할 것이다.
예를 들어 Iterator로 가변 내부 상태를 포함하는 자료구조를 탐색하면서 함수형 방식으로 자료구조에 들어 있는 값의 합계를 계산할 수 있다(이미 설명했듯이 자바에서는 지역 변수 변화가 수반될 수 있다.) 
모듈성이 좋고 멀티코어 프로세서에 적합한 프로그램을 구현하는 데 도움을 주는 함수형 프로그래밍의 기능을 소개하겠다.

#### 함수형 실전 연습

함수형을 처음 접하는 학생들에게 종종 제공되는 간단한 예제를 살펴보자. {1, 4, 9}처럼 List<Integer>가 주어졌을 때 이것의 모든 서브집합의 멤버로 구성된 List<List<Integer>>를 만드는 프로그램을 만든다고 가정하자. 예를 들어 {1, 4, 9}의 서브집합은 {1, 4, 9}, {1, 4}, {1, 9}, {4, 9}, {1}, {4}, {9}, {} 다.
빈 집합{}를 포함해서 총 8개의 서브집합이 존재한다. 
보통 '{1, 4, 9}의 서브집합 중 1을 포함하는 집합과 아닌 집합'으로 구분해서 문제를 풀려 시도할 것이다.
1을 포함하지 않는 부분집합은 {4, 9}의 부분집합이고, 1을 포함하는 부분집합은 {4, 9}의 모든 부분집합에 1을 포함시켜 얻을 수 있다. 이와 같은 접근 방식은 가장 쉽고, 자연스러운 함수형 함수형 자바 프로그래밍이다(여기서 가장 많이 하는 실수는 빈 리스트는 부분집합이 없다고 착각하는 것이다)

```java
static List<List<Integer>> subsets(List<Integer> list) {
	if (list.isEmpty()) {	//List가 비어있다면 비어있는 리스트를 하나 생성하여 반환
		List<List<Integer>> ans = new ArrayList<>();
		ans.add(Collections.emptyList());
		return ans;   //빈 리스트 자신이 서브집합이다.
	}			
	Integer first = list.get(0);    //첫 요소를 꺼냄.
	List<Integer> rest = list.subList(1, List.size());   //첫 요소제외한 여분
	
	//빈 리스트가 아니면 먼저 하나의 요소를 꺼내고 나머지 요소의 모든 서브집합을 찾아서 subans로 전달. subans는 절반의 정답을 포함한다.
	List<List<Integer>> subans = subsets(rest);   //여분을 가지고 재귀 수행
	
	//정답의 나머지 절반을 포함하는 subans2는 subans의 모든 리스트에서 처음 꺼낸 요소를 앞에 추가해서 만든다.
	List<List<Integer>> subans2 = insertAll(first, subans);  //첫 요소와 재귀수행한 여분을 합침
	return concat(subans, subans2);  //둘을 합침
}
```
입력으로 {1,4,9}를 제공하면 결과로 8개의 서브집합을 얻는다.
insertAll과 concat의 구현이 없다. 직접 완성하고 실행해 보자.

insertAll을 정의해보자. 첫 번째 함정이 나타났다.
만약 여러분이 insertAll의 인수를 변환하도록, 즉 subans의 모든 요소가 first를 포함하도록 인수를 변환했다고 가정하자. 결국 subans가 의도하지 않은 값을 포함하면서 이상한 결과가 나온다. (나도 단순하게 인자로 넘어온 subans에 first를 추가했음) 
다음처럼 insertAll을 정의해야 한다.


```java
static List<List<Integer>> insertAll(int first, List<List<Integer>> subans){

        List<List<Integer>> result = new ArrayList<>();
        for (List<Integer> list : subans) {
//리스트를 복사한 다음에 복사한 리스트에 요소를 추가한다. 
//구조체가 가변이더라도 저수준 구조를 복사하진 않는다. (Integer는 가변이 아니다.)
            List<Integer> copyList = new ArrayList<>();  
            copyList.add(first);
            copyList.addAll(list);
            result.add(copyList);
        }
        System.out.println("insertAll = " + result);
        return result;
}
```
subans의 모든 요소를 포함하는 새로운 List를 만들었다는 점에 주목하라. 여기선 Integer 객체가 불변이라는 사실을 이용했다(Integer가 불변이 아니라면 각 요소를 모두 복제해야 한다)
(불변 관련 내용 참조 : https://velog.io/@urtimeislimited/Java-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%97%90%EC%84%9C%EC%9D%98-%EB%B6%88%EB%B3%80%EC%84%B1#referenece)



마지막으로 concat 메서드를 정의한다. 다음은 간단하게 concat을 구현한 코드이므로 ***실무에선 사용하지 않도록 주의하자***.

```java
static List<List<Integer>> concat(List<List<Integer>> subans, List<List<Integer>> subans2) {
        subans.addAll(subans2);

        return subans;
}
```

다음처럼 구현하는 것이 바람직하다.

```java
static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b) {
        List<List<Integer>> r = new ArrayList<>(a);
	r.addAll(b);

        return r;
}
```

왜 두 번째 버전이 더 좋은 코드일까?
두 번째 버전의 concat은 순수 함수다.

내부적으로는 리스트 r에 요소를 추가하는 변화가 발생하지만 반환 결과는 오로지 인수에 의해 이루어지며 인수의 정보는 변경하지 않는다. 이와 달리 첫 번째 버전은 concat(subans, subans2)를 호출한 다음에 subans의 값을 다시 참조하지 않는다는 가정을 한다.(먼말이죠?)
실제로 우리 예제에선 subans의 값을 다시 참조하지 않으므로 더 가벼운 버전의 concat을 사용하는 것이 바람직하다. 각자의 상황에 따라 복제하는 것이 좋을지 잠재적인 버그를 찾기 위해 시간을 소비하는 것이 비용이 적을지 고려해서 어떤 방식을 선택할지 결정할 수 있다.(??!! 당연히 복제가 아닌가?)

'메서드의 첫 번째 인수를 임의의 값으로 바꿀 수 있는 상황에서만 메서드를 사용해야 하며 subsets를 고칠 때는 이 사실을 고려해야 함' 이라는 자세한 설명을 주석으로 추가했어도 여전히 누군가가 코드를 사용할 때는 이런 사실을 고려하기보다는 애초부터 끔찍한 디버깅 문제가 발생할 가능성이 없도록 구현된 코드를 선호할 것이다.

인수에 의해 출력이 결정되는 함수형 메서드의 관점에서 프로그램 문제를 생각하자. (즉, 무엇을 해야 하는가에 중점을 둔다)
이와 같은 방식으로 문제를 접근하면 설계 단계에서 어떻게 문제를 해결할 것이고 무엇을 변화할 것인지 결정하는 기존 방식에 비해 더 생산적일 때가 많다(설계 단계는 이와 같은 결정을 내리기에 너무 이른 상황이기 때문) 무엇을 해야 하는가에 집중할 수 있도록 도움을 주는 함수형 프로그래밍의 한 기법인 재귀를 좀 더 자세히 살펴보자.

### 재귀와 반복

순수 함수형 프로그래밍 언어에선 while, for 같은 반복문을 포함하지 않는다. 왜 그럴까?
이러한 반복문 때문에 변화가 자연스럽게 코드에 스며들 수 있기 때문이다. 
함수형 스타일에서는 다른 누군가가 변화를 알아차리지만 못한다면 아무 상관이 없다고 설명했다.
즉, 지역변수는 자유롭게 갱신할 수 있다.
다음은 자바의 Iterator로 for(Apple a : apples) {}라는 for-each 루프를 표현한 코드다.

```java
Iterator<Apple> it = apples.iterator();
while (it.hasNext) {
	Apple apple = it.next();
	//...
```

위 코드에서 호출자는 변화를 확인할 수 없으므로 아무 문제가 없다(즉, next로 Iterator의 상태를 변환했고, while 바디 내부에서 apple 변수에 할당하는 동작을 할 수 있다.) 하지만 다음 코드처럼 for-each루프를 사용하는 검색 알고리즘은 문제가 될 수 있다.

```java
public void searchForGold(List<String> l, Stats stats) {
	for (String s: l) {
		if("gold".equals(s)) {
			stats.incrementFor("gold");
		}
	}
}
```

(stats라는 loop 밖의 지역변수가 상태가 바뀌는 게 문제인건가?)

루프의 바디에서 함수형과 상충하는 부작용이 발생한다. 즉, 루프 내부에서 프로그램의 다른 부분과 공유되는 stats 객체의 상태를 변화시킨다.

이러한 문제 때문에 하스켈 같은 순수 함수형 프로그래밍 언어에서는 부작용 연산을 원천적으로 제거했다.
(그럼 for문이 없나? 그런가봄 하스켈에선 반복을 재귀를 사용하나 봄, 나중에 찾아봐야지)
그럼 어떻게 프로그램을 구현하나? 이론적으로 반복을 이용하는 모든 프로그램은 재귀로도 구현할 수 있는데 재귀를 이용하면 변화가 일어나지 않는다. 재귀를 이용하면 루프 단계마다 갱신되는 반복 변수를 제거할 수 있다. 다음은 팩토리얼 함수로, 반복과 재귀방식으로 해결할 수 있는 고전적 학교문제다. 여기서 입력은 1보다 크다고 가정한다.

반복 방식의 팩토리얼

1* 2* 3* 4

``java
static int factorialIterative(int n) {
	int r = 1;
	for (int i = 1; i <= n; i++) {
		r *= i;
	}
	return r;
}
```

재귀방식의 팩토리얼

```java
static long factorialRecursive(long n) {
	return (n == 1) ? 1 : n * factorialRecursive(n-1);
}
```

첫째 예제는 일반적인 루프를 사용한 코드로 매 반복마다 변수 r과 i가 갱신된다.
둘째 예제는 재귀(자신을 호출) 방식의 코드로 좀 더 수학적인 형식으로 문제를 해결한다.

자바8 스트림을 통해 더 단순한 팩토리얼을 정의해보자.

스트림 팩토리얼

```java
static long factorialStream(long n) {
	return LongStream.rangeClosed(1, n)
			.reduce(1, (long a, long b) -> a * b);
}
```

이제 효율성 측면을 살펴보자.
함수형 프로그래밍의 장점이 분명히 있지만 무조건 반복보다는 재귀가 좋다고 주장하는 함수형 프로그래밍 광신도의 주장에 주의해야 한다.
일반적으로 반복코드보다 재귀 코드가 더 비싸다.
왜 그럴까?(함수를 호출할 때마다 변수 메모리를 확보하기 때문에)
factorialRecursive 함수를 호출할 때마다 호출 스택에 각 호출시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어진다.
즉 재귀 팩토리얼의 입력값에 비례해서 메모리 사용량이 증가한다. 따라서 큰 입력값을 사용하면 다음처럼 StrackOverflowError가 발생한다.

Exception in thread "main" java.lang.StackOverflowError

그러면 재귀는 쓸모없는 것인가? 그렇지 않다.
함수형 언어에서는 꼬리 호출 최적화라는 해결책을 제시한다.
(꼬리 호출 최적화? tail-call optimization, 메모이제이션 같은 건가?)

꼬리 재귀 팩토리얼

```java
static long factorialTailRecursive(long n) {
	return factorialHelper(1, n);
}
static long factorialHelper(long acc, long n) {
	return n == 1 ? acc : factorialHelper(acc * n, n-1);
}
```
factorialHelper에서 재귀 호출이 가장 마지막에서 이루어지므로 꼬리 재귀다. 
반면 이전 factorialRecursive에서 마지막으로 수행한 연산은 n과 재귀 호출의 결과값의 곱셈이다.

중간 결과를 각각의 스택프레임으로 저장해야 하는 일반 재귀와 달리 꼬리 재귀에서는 컴파일러가 하나의 스택 프레임을 재활용할 가능성(가능성??언제 재활용하는지 알 수는 없나?)이 생긴다.
사실 factorialHelper의 정의에서는 중간 결과(팩토리얼의 부분결과)를 함수의 인수로 직접 전달한다.
(1~n의 순차적 인자 뿐만 아니라 그 인자를 사용한 함수의 결과 또한 다음 재귀함수의 인자로 활용된다.)

안타깝게도 자바는 이와 같은 최적화를 제공하지 않는다.
그럼에도 여전히 고전적인 재귀보다는 여러 컴파일러 최적화 여지를 남겨둘 수 있는 꼬리 재귀를 적용하는 것이 좋다.
스칼라, 그루비 같은 최신 JVM 언어는 이와 같은 재귀를 반복으로 변환하는 최적화를 제공한다(속도의 손실이 없이). 결과적으로 순수 함수형을 유지하면서도 유용성 뿐 아니라 효율성까지도 잡을 수 있다.

결론적으로 자바 8에선 반복을 스트림으로 대체해서 변화를 피할 수 있다.
(모든 것을 스트림으로 해야 하는가?)
또한 반복을 재귀로 바꾸면 더 간결하고 부작용 없는 알고리즘을 만들 수 있다.
실제로 재귀를 이용하면 쉽게 읽고 쓰고 이해할 수 있는 예제를 만들 수 있다.
약간의 실행차이 보단 프로그래머의 효율성이 더 중요할 때도 많다.


---

# 함수형 프로그래밍 기법

### 함수는 모든 곳에 존재한다

함수형 프로그래밍이란 함수나 메서드가 순수함수처럼 동작함을 의미(부자용 없이)
함수형 프로그래밍에선 함수를 마치 일반값처럼 사용해서 인수로 전달하거나 결과로 반환받거나 자료구조에 저장할 수 있다. 
일반값처럼 취급할 수 있는 함수를 ***일급 함수***라고 한다.
자바8이전버전과 구별되는 특징 중 하나가 일급 함수를 지원한다는 점이다.
자바8에선 ::연산자로 메서드 참조를 만들거나 (int x)-> x + 1 같은 람다 표현식으로 직접 함숫값을 표현해서 메서드를 함숫값으로 사용할 수 있다. 자바8은 다음과 같은 메서드 참조로 Integer.parseInt를 저장할 수 있다.
```java
Function<String, Integer> strToInt = Integer::parseInt;
```

#### 고차원 함수

지금까지 함숫값을 자바8 스트림 처리 연산으로 전달(4~7장)하거나 filterApples에 함숫값으로 Apple::isGreenApple을 전달해서 동작 파라미터화를 달성(1~2장)하는 용도로만 사용했다. 이는 함숫값 활용의 일부에 불과하다.
함수를 인수로 받아서 다른 함수로 반환하는 정적 메서드 Comparator.comparing도 있었다.

```java
Comparator<Apple> c = comparing(Apple::getWeight);
```

3장에서는 함수를 조립해서 연산 파이프라인을 만들 때 위 코드와 비슷한 기능을 활용했다.

```java
Function<String, String> transformationPipeline = addHeader.andThen(Letter::checkSpelling).andThen(Letter::addFooter);
```

함수형 프로그래밍 커뮤니티에 따르면 Comparator.comparing처럼 다음 중 하나 이상의 동작을 수행하는 함수를 ***고차원 함수***라 부른다.
- 하나 이상의 함수를 인수로 받음.
- 함수를 결과로 반환

자바8에선 함수를 인수로 전달할 수 있을 뿐 아니라 결과로 반환하고, 지역 변수로 할당하거나, 구조체로 삽입할 수 있으므로 자바8의 함수도 고차원 함수라고 할 수 있다.
예를 들어 계산기에서 문자열 'sin'을 Function<Double, Double>로 매핑하는 Map<String, Function<Double, Double>>이 있다고 가정하자(최종적으로 Math::sin을 획득)


Function<Function<Double,Double>, Function<Double,Double>>

예를 들어 위 함수는 (Double x) -> x * x라는 함수를 인수로 받아 (Double x) -> 2 * x 같은 함수를 결과로 반환한다. 결과가 함수 형식(가장 왼쪽의 Function)이므로 미분 함수를 다른 함수로 다시 전달할 수 있다. 다음의 미분 형식과 시그니처는 결국 위 함수와 같다.

Function<Double,Double> differentiate(Function<Double,Double> func)


부작용과 고차원 함수

스트림 연산으로 전달하는 함수는 부작용이 없어야 하며, 부작용을 포함하는 함수를 사용하면 문제가 생긴다.(부작용을 포함하는 함수를 사용하면 부정확한 결과가 발생하거나 레이스 컨디션 때문에 예상치 못한 결과가 발생) 고차원 함수를 적용할 때도 같은 규칙이 적용된다.
고차원 함수나 메서드를 구현할 때 어떤 인수가 전달될지 알 수 없으므로 인수가 부작용을 포함할 가능성을 염두에 둬야 한다.(함수들이 어떻게 연결되는지 함수명만으로 파악이 힘들다는 소리 같음. 근데 OOP로 추상화 하는 것 자체가 그런거지 않나 싶음.)
함수를 인수로 받아 사용하면서 코드가 정확히 어떤 작업을 수행하고 프로그램의 상태를 어떻게 바꿀지 예측하기 어려워진다. 디버깅도 어려워질 것이다. 따라서 인수로 전달된 함수가 어떤 부작용을 포함하게 될지 정확하게 문서화하는 것이 좋다. 물론 부작용을 포함하지 않을 수 있다면 가장 좋을 것이다.(다른 사람과 같이 작업 한다면 혹은 본인이 실수할 수도 있어서 부작용을 포함하지 않는다는 보장이 없기 때문에 문서화가 필요할 듯)

이제 함수를 모듈화하고 코드를 재사용하는 데 도움을 주는 기법인 커링을 살펴보자.


#### 커링

국제화 예제를 먼저 살펴보자. 국제화는 단위 변환 문제가 발생할 수 있다.

보통 변환 요소와 기준치 조정 요소가 단위 변환 결과를 좌우한다.

예시) 섭씨를 화씨로 변환하는 공식

CtoF(x) = x*9/5 + 32

다음과 같은 패턴으로 단위를 표현할 수 있다.
1. 변환요소를 곱함
2. 기준치 조정 요소를 적용

다음과 같은 메서드로 변환 패턴을 표현할 수 있다.

```java
static double convertor(double x, double f, double b) {
	return x * f + b;
}
```
x는 변환하려는 값이고, f는 변환 요소며, b는 기준치 조정 요소다.
세 개의 인수를 받는 converter라는 메서드를 만들어 문제를 해결하는 방법도 있지만 인수에 변환 요소와 기준치를 넣는 일은 귀찮고 오타 발생우려도 있다.

각각 변환하는 메서드를 따로 만들면 로직을 일반화 하지 못해서 재활용이 안된다.

기존 로직을 활용해서 변환기를 특정 상황에 적용할 수 있는 방법이 있다.
다음은 커링이라는 개념을 활용해서 한 개의 인수를 갖는 변환 함수를 생산하는 '팩토리'를 정의하는 코드다.

```java
static DoubleUnaryOperator curriedConverter(double f, double b) {
	return (double x) -> x * f + b;
}
```
위 메서드에 변환요소(f)와 기준치(b)만 넘겨주면 우리가 원하는 작업을 수행할 함수가 반환된다.
예를 들어 다음은 팩토리를 이용해서 원하는 변환기를 생성하는 코드다.


```java
DoubleUnaryOperator convertCtoF = curriedConverter(9.0/5, 32);
DoubleUnaryOperator convertUSDtoGBP = curriedConverter(0.6, 0);
DoubleUnaryOperator convertKtoM = curriedConverter(0.6214, 0);
```

DoubleUnaryOperator는 applyAsDouble이라는 메서드를 정의하므로 다음처럼 변환기를 사용할 수 있다.

double gbp = convertUSDtoGBP.applyAsDouble(1000);

결과적으로 기존의 변환 로직을 재활용하는 유연한 코드를 얻었다. 우리가 어떤 작업을 했는지 다시 생각해보자. x, f, b라는 세 인수를 converter 메서드로 전달하지 않고 f, b 두 가지 인수로 함수를 요청했으며 반환된 함수에 인수 x를 이용해서 x * f + b라는 결과를 얻었다. 이런 방식으로 변환 로직을 재활용할 수 있으며 다양한 변환 요소로 다양한 함수를 만들 수 있다.


커링의 이론적 정의(커링이란 가죽의 유연성을 높이기 위해 가죽을 가지제로 처리하는 일)

커링은 x와 y라는 두 인수를 받는 함수 f를 한 개의 인수를 받는 g라는 함수로 대체하는 기법이다.
이때 g라는 함수 역시 하나의 인수를 받는 함수를 반환한다. 함수g와 원래 함수 f가 최종적으로 반환하는 값은 같다. 즉, f(x,y) = (g(x))(y)가 성립한다.

물론 이 과정을 일반화할 수 있다. 여섯 개의 인수를 가진 함수를 커리해서 우선 2,4,6번째 인수를 받아 5번째 인수를 받는 함수를 반환하고 다시 이 함수는 남은 1,3번째 인수를 받는 함수를 반환한다.

이와 같은 여러 과정이 끝까지 완료되지 않은 상태를 가리켜 '함수가 부분적으로 적용되었다'라고 말한다.


#### 영속 자료구조

이 절에서는 함수형 프로그램에서 사용하는 자료구조를 살펴본다. 
함수형 프로그램에서는 함수형 자료구조, 불변 자료구조 등의 용어도 사용하지만 보통은 영속 자료구조라고 부른다('영속persistent'이라는 단어는 데이터베이스에서 프로그램 종료 후에도 남아있음을 의미하는 영속과는 다른 의미다.)

함수형 메서드에서는 전역 자료구조나 인수로 전달된 구조를 갱신할 수 없다. 왜 그럴까? 자료구조를 바꾼다면 같은 메서드를 두 번 호출했을 때 결과가 달라지면서 참조 투명성에 위배되고 인수를 결과로 단순하게 매핑할 수 있는 능력이 상실되기 때문이다.

##### 파괴적인 갱신과 함수형

자료구조를 갱신할 때 발생할 수 있는 문제를 확인해보자. A에서 B까지 기차여행을 의미하는 ***가변***TrainJourney 클래스가 있다고 가정하자. TrainJourney는 간단한 단방향 연결리스트로 구현되며 여행 구간의 가격 등 상세 정보를 포함하는 int 필드를 포함한다. 다음 코드에서 보여주는 것처럼 기차여행에서는 
여러 TrainJourney 객체를 연결할 수 있는 onward(이어지는 여정을 의미)라는 필드가 필요하다. 직통열차나 여정의 마지막 구간에서는 onward가 null이 된다.

```java
class TrainJourney {
	public int price;
	public TrainJourney onward;
	public TrainJourney(int p, TrainJourney t) {
		price = p;
		onward = t;
	}
}
```
이때 X에서 Y까지 그리고 Y에서 Z까지의 여행을 나타내는 별도의 TrainJourney 객체가 있다고 가정.
아마 두 개의 TrainJourney 객체를 연결해서 하나의 여행을 만들 수 있을 것이다.(X -> Y -> Z)

기존의 단순한 명령형 메서드라면 다음처럼 기차여행을 연결할 것이다.
```java
static TrainJourney link(TrainJourney a, TrainJourney b) {
	if (a == null) return b;
	TrainJourney t = a;
	while(t.onward != null) {
		t = t.onward;
	}
	t.onward = b;
	return a;
```

위 코드는 a의 TrainJourney에서 마지막 여정을 찾아 a의 리스트 끝 부분을 가리키는 null을 리스트 b로 대체한다(a가 아무 요소도 포함하지 않는 상황은 따로 고려해야 한다.) 
여기서 문제가 발생한다.
firstJourney라는 변수는 X에서 Y로의 경로를 포함하고, secondJourney라는 변수는 Y에서 Z로의 경로를 포함한다. link(firstJourney, secondJourney)를 호출하면 firstJourney가 secondJourney를 포함하면서 파괴적인 갱신(즉, firstJourney를 변경시킴)이 일어난다.
결과적으로 firstJourney의 변수는 X에서 Y가 아닌 X에서 Z로의 여정을 의미하게 된다.
이렇게 되면 firstJourney에 의존하는 코드가 동작하지 않게 된다.
firstJourney가 서울역에서 구미역까지의 기차여정이었는데 갑자기 서울역에서 구미역을 지나 부산역까지 도착하는 여정으로 바뀐다면 firstJourney를 참고하던 사용자는 혼란에 빠질 것이다. 이렇게 자료구조를 바꾸면서 생기는 버그를 어떻게 처리할 것인지 문제를 해결해야 한다.(자료구조를 바꾼다는 게 필드를 추가한다 던게 아니라 필드에 있던 정보가 바뀌는 것을 의미하나 봄)

함수형에서는 이 같은 부작용을 수반하는 메서드를 제한하는 방식으로 문제를 해결한다.
계산 결과를 표현할 자료구조가 필요하면 기존의 자료구조를 갱신하지 않도록 새로운 자료구조를 만들어야 한다.
이는 표준 객체지향 프로그래밍의 관점에서도 좋은 기법이다. 함수형을 따르지 않는 프로그램의 문제 중 하나는 부작용을 포함하는 코드와 관련하여 '이 점을 기억해야 함', '문서화해둠' 같은 주석을 프로그래머가 과도하게 남용할 수 있다는 것이다.
이 같은 주석은 나중에 코드를 유지보수하는 프로그래머를 괴롭힌다.
따라서 다음처럼 깔끔한 함수형 해결방법을 사용하는 것이 좋다.

```java
static TrainJourney append(TrainJourney a, TrainJourney b) {
	return a == null ? b : new TrainJourney(a.price, append(a.onward, b)); //재귀사용
```

이 코드는 명확하게 함수형이며 기존 자료구조를 변경하지 않는다(전역 심지어 지역적인 변화도 일어나지 않는다). 하지만 TrainJourney 전체를 새로 만들지 않는다. a가 n요소의 시퀀스고 b가 m요소의 시퀀스라면 n+m요소의 시퀀스를 반환한다. 여기서 첫 번째 n요소는 새로운 노드며 마지막 m 요소는 TrainJourney b와 공유되는 요소다. 주의할 점은 사용자 역시 append의 결과를 갱신하지 말아야 한다는 것이다. 만약 append의 결과를 갱신하면 시퀀스 b로 전달된 기차 정보도 바뀐다. 


#### 트리를 사용한 다른 예제

이번에는 다른 자료구조를 살펴보자. HashMap 같은 인터페이스를 구현할 때는 이진 탐색 트리가 사용된다.
Tree는 문자열 키와 int 값을 포함한다.
예를 들어 이름 키와 나이 정보값을 포함할 수 있다.

```java
class Tree {
	private String key;		//키는 문자열
	private int val;		//값은 int
	private Tree left, right;	//트리로 왼쪽, 오른쪽
	public Tree(String k, int v, Tree l, Tree r) {		//트리는 키,값,왼,오 입력
		key = k; val = v; left = l; right = r;
	}
}

class TreeProcessor {
	public static int lookup(String k, int defaultval, Tree t) {  //찾기, 키랑 기본값
		if (t == null) return defaultval; //t가 null이면 기본값을 반환해라
		if (k.equals(t.key)) return t.val; //k키랑 t의 키가 같다면 t의 값을 반환
		return lookup(k, defaultval,
				//재귀 이진 탐색으로 최종 트리까지 타고 내려감.
				k.compareTo(t.key) < 0 ? t.left : t.right); 
	}
	//트리의 다른 작업을 처리하는 기타 메서드
}
```

이제 이진 탐색 트리를 이용해서 문자열값으로 int를 얻을 수 있다.
주어진 키와 연관된 값을 어떻게 갱신할 수 있는지 살펴보자(우리가 찾으려는 키가 트리에 존재한다고 가정)

```java
public static void update(String k, int newval, Tree t) {
	if (t == null) { /* 새로운 노드를 추가해야 함 */ }
	else if (k.equals(t.key)) t.val = newval;
	else update(k, newval, k.compareTo(t.key) < 0 ? t.left : t.right);
}
```

새로운 노드를 추가할 때는 주의해야 한다. 가장 쉬운 방법은 update 메서드가 탐색한 트리를 그대로 반환하는 것이다(새로운 노드를 추가하지 않으면 기존 트리가 그대로 반환된다).
하지만 이 방법은 그리 깔끔하지 못하다(사용자는 update가 즉석에서 트리를 갱신할 수 있으며, 전달한 트리가 그대로 반환된다는 사실, 원래 트리가 비어있으면 새로운 노드가 반환될 수 있다는 사실을 모두 기억해야 하기 때문이다).

```java
public static Tree update(String k, int newval, Tree t) {
	if (t == null) 
		t = new Tree(k, newval, null, null); //비어있다면 키, 값대로 루트 추가
	else if (k.equals(t.key))	//키가 같다면 t값을 갱신
		t.val = newval;
	else if (k.compareTo(t.key) < 0)  //키를 비교해서 작으면 왼쪽 크면 오른쪽 트리로 이동
		t.left = update(k, newval, t.left);
	else
		t.right = update(k, newval, t.right);
	return t;
```
두 가지 update 버전 모두 기존 트리를 변경한다. 즉, 트리에 저장된 맵의 모든 사용자가 변경에 영향을 받는다.
(재귀로 풀긴 하지만 t를 수정하기 때문에 기존 트리를 변경함)

#### 함수형 접근법 사용

이 문제를 함수형으로 어떻게 처리할 수 있을까?
우선 새로운 키/값 쌍을 저장할 새로운 노드를 만들어야 한다.
또한 트리의 루트에서 새로 생성한 노드의 경로에 있는 노드들도 새로 만들어야 한다(보통 노드를 새로 만드는 동작은 생각보다 비싸지 않은 편이다. d라는 깊이를 갖는 트리고 균형이 어느 정도 잡혀있다면 2^d 만큼의 개체를 가지고 있으므로 재생성 과정은 그중 일부 노드를 생성하는 과정에 불과하다)

??이렇게 사용하기 빡세면 함수형 프로그래밍 어떻게 함. 이것도 나중에 적응되면 익숙해져서 쉽게 할 수 있을까?

```java
public static Tree fupdate(String k, int newval, Tree t) {
	return (t == null) ?
		new Tree(k, newval, null, null) :
			k.equals(t.key) ?
				new Tree(k, newval, t.left, t.right) :
			k.compareTo(t.key) < 0 ?
				new Tree(t.key, t.val, fupdate(k, newval, t.left), t.right) :
				new Tree(t.key, t.val, t.left, fupdate(k, newval, t.right));
}
```


위 코드에서는 if-then-else 대신 하나의 조건문을 사용했는데 이렇게 해서 위 코드가 부작용이 없는 하나의 표현식임을 강조했다. 하지만 취향에 따라 if-then-else문으로 코드를 구현할 수 있다.

update와 fupdate의 차이는 뭘까? 이전에 update 메서드는 모든 사용자가 같은 자료구조를 공유하며 프로그램에서 누군가 자료구조를 갱신했을 때 영향을 받는다는 점을 설명했다.
따라서 비함수형 코드에서는 누군가 언제든 트리를 갱신할 수 있으므로 트리에 어떤 구조체의 값을 추가할 때마다 값을 복사했다. 반면 fupdate는 순수한 함수형이다. fupdate에서는 새로운 Tree를 만든다.
하지만 ***인수를 이용해서 가능한 한 많은 정보를 공유한다.***(??먼말이지??)
사람의 이름과 나이를 노드로 저장하는 트리를 만들었다고 가정하자. 여기서 fupdate를 호출하면 기존의 트리를 갱신하는 것이 아니라 새로운 노드를 만든다.

이와 같은 함수형 자료구조를 영속(저장된 값이 다른 누군가에 의해 영향을 받지 않는 상태)이라고 하며 따라서 프로그래머는 fupdate(뭔가 했더니 함수형 업데이트구만)가 인수로 전달된 자료구조를 변화시키지 않을 것이라는 사실을 확신할 수 있다. ***'결과 자료구조를 바꾸지 말라'***는 것이 자료구조를 사용하는 모든 사용자에게 요구하는 단 한가지 조건이다. 이를 무시하고 fupdate의 결과를 바꾸는 사람도 있을 것이다(예를 들어 Emily의 20을 다른 숫자로 바꿈).  결과 자료구조를 바꾸지 말라는 조건을 무시한다면 fupdate로 전달된 자료구조에 의도치 않은 그리고 원치 않는 갱신이 일어난다.
fupdate가 좀 더 효율적일 때가 많다. '기존 구조를 변화시키지 않는다'라는 법칙 덕분에 조금 다른 구조체(예를 들어 사용자 A가 확인하는 트리와 사용자 B가 확인하는 갱신된 버전처럼) 간의 공통부분을 공유할 수 있다는 점에서 다른 구조체와 조금 다르다.
Tree 클래스의 key, val, left, right 필드를 final로 선언함으로써 '기존 구조를 변화시키지 않는다'는 규칙을 강제할 수 있다. 하지만 final은 필드에만 적용되며 객체에는 적용되지 않으므로 각 객체의 필드에 final을 적절하게 사용해야 함을 기억하자.

어떤 사람은 '나는 일부 사용자만 볼 수 있게 트리를 갱신하면서도 다른 일부 사용자는 이를 알아차릴 수 없게 하고 싶다'고 말한다.
두 가지 방법이 있다.
하나는 고전적인 자바 해법이다(어떤 값을 갱신할 때 먼저 복사해야 하는지 주의 깊게 확인).
다른 하나는 함수형 해법이다.
즉, 갱신을 수행할 때마다 논리적으로 새로운 자료구조를 만든 다음에(변화가 일어나지 않도록) 사용자에게 적절한 버전의 자료구조를 전달할 수 있다. 
API로 이 방법을 강제할 수 있다. 자료구조의 고객이 볼 수 있도록 갱신을 수행해야 한다면 최신 버전을 반환하는 API를 사용할 수 있다.  반면에 보이지 않도록 갱신을 수행해야 한다면, 예를 들어 오래 실행되는 통계분석 같은 경우에는 변화가 일어나지 않도록 단순히 인수를 복사한 값을 반환하면 된다.

이 기법은 레이저로 단 한 번 CD-R에 파일을 '갱신'하는 동작과 비슷하다. 여러 파일의 버전을 모두 CD에 저장했다가 적잘한 파일 시작 주소 블록을 전달할 수 있다(스마트 CD 젲가 소프트웨어라면 여러 파일 버전의 공통 부분을 공유하는 기능을 제공할 수도 있다). 자바는 CD보단 상황이 좋다. 자바에서 자료구조의 예전 버전은 적어도 자동으로 가비지 컬렉트되기 때문이다.
(?솔직히 이번 파트는 무슨 소린지 잘 이해가 되지 않음. 대충 추상적으로 의미만 파악함.)


### 스트림과 게으른 평가

스트림은 데이터 컬렉션을 처리하는 편리한 도구임을 살펴봤다. 효율적인 구현 및 여러 이유로 자바8 설계자들은 스트림을 조금 특별한 방법으로 자바8에 추가했다. 그중 하나로 스트림은 단 한 번만 소비할 수 있다는 제약이 있어서 스트림은 재귀적으로 정의할 수 없다. 이 절에서는 이와 같은 제약 때문에 어떤 문제가 발생하는지 살펴볼 것이다.(그러네 스트림은 한 번만 사용하니까 함수형으로 못하는 구나. 나는 스트림을 사용하는 게 함수형 프로그래밍의 일부분이라고 생각했는데 아니네?)

#### 자기 정의 스트림

소수를 생성하는 6장의 예제로 재귀 스트림을 살펴보자. 다음 코드처럼 소수 스트림을 계산할 수 있었다.

```java
public static Stream<Integer> primes(int n) {
	return Stream.iterate(2, i -> i + 1)	//반복자 2 부터 스트림 생성
		.filter(MyMathUtils::isPrime)
		.limit(n);
}

public static boolean isPrime(int candidate) {
	int candidateRoot = (int) Math.sqrt((double) candidate);
	return IntStream.rangeClosed(2, candidateRoot)
			.noneMatch(i -> candidate % i == 0);
}
```
추가적으로 candidate number로 정확히 나누어 떨어지는지 매번 모든 수를 반복 확인했다.(실제로 합성수=서로 다른 두 개 이상의 소수의 곱으로 이루어진 수, 는 나누어 떨어지는지 확인할 필요가 없다)
이론적으로 소수로 나눌 수 있는 모든 수는 제외할 수 있다.

결국 소수의 배수라면 제외해도 됨.

다음은 소수로 나눌 수 있는 수를 제외하는 과정을 설명한다.

1. 소수를 선택할 숫자 스트림이 필요하다.
2. 스트림에서 첫 번째 수(스트림의 머리)를 가져온다. 이 숫자는 소수다(처음은 2)
3. 이제 스트림의 꼬리에서 가져온 수로 나누어 떨어지는 모든 수를 걸러 제외시킨다.
4. 이렇게 남은 숫자만 포함하는 새로운 스트림에서 소수를 찾는다. 이제 1번부터 다시 이 과정을 반복하게 된다. 따라서 이 알고리즘은 재귀다.

이 알고리즘은 여러 가지 면에서 '부족한' 알고리즘이다. 다만 스트림이 어떻게 동작하는지 쉽게 보여줄 수 있는 좋은 간단한 알고리즘이다. 스트림 API로 이 알고리즘을 구현해보자.

*** 1단계 : 스트림 숫자 얻기 ***
IntStream.iterate 메서드를 이용하면 2에서 시작하는 무한 숫자 스트림을 생성할 수 있다.
```java
static IntStream numbers() {
	return IntStream.iterate(2, n -> n + 1);
}
```
*** 2단계 : 머리 획득 ***
IntStream은 첫 번째 요소를 반환하는 findFirst라는 메서드를 제공한다.
```java
static int head(IntStream numbers) {
	return numbers.findFirst().getAsInt();
}
```

*** 3단계 : 꼬리 필터링 ***

스트림의 꼬리를 얻는 메서드를 정의한다.

```java
static IntStream tail(IntStream nubmers) {
	return numbers.skip(1);		//처음 1개의 스트림요소(head)을 버리고 반환
}
```

다음처럼 획득한 머리로 숫자를 필터링할 수 있다.
```java
IntStream numbers = numbers();	//
int head = head(numbers);
IntStream filtered = tail(numbers).filter(n -> n % head != 0);
```

*** 4단계 : 재귀적으로 소수 스트림 생성 ***

가장 어려운 부분이다. 다음 코드에서 보여주는 것처럼 반복적으로 머리를 얻어서 스트림을 필터링하려 할 수 있다.

```java
static IntStream primes(IntStream numbers) {
	int head = head(numbers);
	return IntStream.concat(
		IntStream.of(head),
		primes(tail(numbers).filter(n -> n % head != 0))  //2, 
	);
}
```

***나쁜 소식***

안타깝게도 4단계 코드를 실행하면 "java.lang.IllegalStateException: stream has already been operated upon or closed"라는 에러가 발생한다. 사실 우리는 스트림을 머리와 꼬리로 분리하는 두 개의 최종연산 findFirst와 skip을 사용했다. 4장에선 최종연산을 스트림에 호출하면 스트림이 완전 소비된다는 사실을 증명했다.


***게으른 평가***

위 나쁜 소식보다 더 심각한 문제가 있다. IntStream.concat은 두 개의 스트림 인스턴스를 인수로 받는다. 두 번째 인수가 primes를 직접 재귀적으로 호출하면서 무한 재귀에 빠진다. '재귀적 정의 허용하지 않음'같은 자바8의 스트림 규칙은 우리에게 아무 해도 끼치지 않으며 오히려 이 규칙 덕분에 데이터베이스 같은 질의를 표현하고 병렬화할 수 있는 능력을 얻을 수 있다. 그래서 자바8 설계자는 이 같은 제한을 두기로 결정했다. 사실 스칼라, 하스켈 같은 함수형 언어에서는 자바8에 비해 좀 더 일반적인 기능과 모델을 제공한다. 결론적으로 concat의 두 번째 인수에서 primes를 게으르게 평가하는 방식으로 문제를 해결할 수 있다(좀 더 기술적인 프로그래밍 언어의 용어로는 게으른 평가 비엄격한 평가 또는 이름에 의한 호출이라 한다)
즉 소수를 처리할 필요가 있을 때만 스트림을 실제로 평가한다. 스칼라에서도 이와 같은 기능을 제공한다.
다음 예제는 스칼라로 알고리즘을 구현한 코드다. 여기서 #:: 연산자는 게으른 연결을 담당한다.(즉 실제 스트림을 소비해야 하는 상황이 되었을 때 인수를 평가한다.)

```scala
def numbers(n: Int): Stream[Int] = n #:: numbers(n+1)

def primes(numbers: Stream[Int]): Stream[Int] = {
numbers.head #:: primes(numbers.tail filter (n -> n % numbers.head != 0))
}
```

위 코드는 자바와 다른 함수형 언어가 어떻게 다른지 보여주는 것뿐 코드를 이해하기 어렵다 걱정할 필요없다.
인수가 어떻게 평가되는지 살펴보자.
자바에서는 메서드를 호출하면 모든 인수가 즉시 평가된다.(즉시 평가된다는 게 뭐지?)
하지만 스칼라에서는 #:: 을 사용한 연결식이 즉시 반환될 뿐이며 필요한 시점이 되어서야 각 요소가 평가된다.
이제 자바로 게으른 리스트 평가를 구현하는 방법으로 되돌아가자.

#### 게으른 리스트 만들기

'자바8의 스트림은 게으르다'라는 설명을 들어봤을 것이다.(한 번도 안들어봤음 스트림 자체를 첨써봐서...)
자바8의 스트림은 요청할 때만 값을 생성하는 블랙박스와 같다.
스트림에 일련의 연산을 적용하면 연산이 수행되지 않고 일단 저장된다.











