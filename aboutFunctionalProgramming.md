# 함수형 관점으로 생각하기

함수형(functional)은 일급함수와 관련이 있으며 때로는 객체 변화를 제한하는 것이 함수형과 밀접한 관련을 갖는다.

***함수형을 적용하면 어떤 점이 좋을까?***


### 시스템 구현과 유지보수

누군가 우리에게 이미 구현되어 있지만 실제 경험해본 적은 없는 대규모 소프트웨어 시스템 업그레이드 관리를 요청했다고 가정하자.

이 요청을 받아들일 것인가?

'먼저 프로그램 내에 synchronized가 없다면 시스템의 구조를 자세히 검토해보라'-자바 개발자사이의 풍문이 떠돈다.

지금까지는 자바8의 스트림을 이용하면 잠금(locking)문제를 신경 쓰지 않을 수 있었다. 단, 자바8의 스트림을 이용하려면 상태 없는 동작이어야 한다는 조건을 만족해야 한다(즉, 스트림 처리 파이프라인의 함수는 다른 누군가가 변수의 값을 바꿀 수 있는 상태에 있는 변수-외부변수-를 사용하지 않는다.)
또한 쉽게 유지보수할 수 있으려면 프로그램이 어떤 모습이어야 할까? 프로그램이 시스템의 구조를 이해하기 쉽게 클래스 계층으로 반영한다면 좋을 것이다.
결합도(coupling)와 응집도(cohesion)라는 소프트웨어 엔지니어링 도구로 프로그램 구조를 평가할 수 있다.

그러나 실질적으로 많은 프로그래머가 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게 된다.
코드 크래시는 예상하지 못한 변숫값 때문에 발생할 수 있다.
왜 그리고 어떻게 변숫값이 바뀐 걸까?
유지보수 중 이런 일이 얼마나 자주 일어나는지 생각해보라.
함수형 프로그래밍이 제공하는 부작용 없음과 불변성이라는 개념이 이 문제를 해결하는 데 도움을 준다.

#### 공유된 가변 데이터

변수가 예상하지 못한 값을 갖는 이유는? 시스템의 여러 곳에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다. (DB처럼, 따라서 locking이 중요하다. 하지만 locking은 병목현상을 발생시킬 수 있다.)
리스트를 참조하는 여러 클래스가 있다고 가정하자.
리스트의 소유자는 어느 클래스인가?
이들 중 하나의 클래스가 리스트를 갱신하면 어떻게 될까?
다른 클래스는 리스트가 갱신되었다는 사실을 알고 있을까?
다른 클래스에 리스트가 갱신되었음을 어떻게 알려줄 수 있을까?
리스트 갱신 사실을 알리는 것이 좋을까 아니면 안전하게 리스트 사본을 만드는 것이 나을까?

이처럼 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.

어떤 자료구조도 바꾸지 않는 시스템이 있다고 가정하자.
예상하지 못하게 자료구조의 값이 바뀔 일이 없으니 얼마나 유지보수하기 쉽겠는가?!
자신을 포함하는 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수(pure)메서드 또는 부작용 없는(side-effect free)메서드 라고 부른다.

구체적으로 부작용은 무엇일까? 함수 내에 포함되지 못한 기능을 부작용이라고 한다.
- 자료구조를 고치거나 필드에 값을 할당(setter 메서드 같은 생성자 이외의 초기화 동작)
- 예외 발생
- 파일에 쓰기 등의 I/O 동작 수행

이러한 부작용은 불변객체를 이용해서 없앨 수도 있다. 불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않는다. 즉, 인스턴스화한 불변 객체의 상태는 결코 예상하지 못한 상태로 바뀌지 않는다.(그러면 해당 객체의 변경된 값을 사용하려면 항상 복사본을 사용해서 값을 사용해야 하는 건가?)
따라서 불변 객체는 복사하지 않고 공유할 수 있으며, 객체의 상태를 바꿀 수 없으므로 스레드 안전성을 제공한다.

어떤 사람은 실제 시스템에서 부작용을 없앤다는 것이 현실적으로 가능한지 의아해 할 수 있다. 
이 책을 읽고 부작용을 없앨 수 있다는 사실을 확신하기 바란다.
부작용 없는 시스템 컴포넌트에서는 메서드가 서로 간섭하는 일이 없으므로 잠금을 사용하지 않고도(병목없이) 멀티코어 병렬성을 사용할 수 있다. 또한 프로그램의 어떤 부분이 독립적인지 바로 이해할 수 있다.

부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래되었다.
함수형 프로그래밍의 기반을 이루는 개념인 선언형 프로그래밍을 살펴보자.(스트림에서 사용했던 내용인 듯)


#### 선언형 프로그래밍

프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있다. '이 일을 먼저하고, 그다음에 저 값을 갱신하고, 그다음에...' 처럼 작업을 어떻게 수행할 것인지에 집중하는 방법이 있다.
이처럼 '어떻게'에 집중하는 프로그래밍 형식은 고전의 객체지향 프로그래밍에서 이용하는 방식이다.
때로는 이를 명령형 프로그래밍이라고 부르기도 하는데 다음 코드에서 보여주는 것처럼 (할당, 조건문, 분기문, 루프 등) 명령어가 컴퓨터의 저수준 언어와 비슷하게 생겼기 때문이다.

```java
Transaction mostExpensive = transaction.get(0);
if(mostExpensive == null)
	throw new IllegalArgumentException("Empty list of transactions")

for (Transaction t: transactions.subList(1, transactions.size())) {
	if (t.getValue() > mostException.getValue()) {
		mostExpensive = t;
	}
}
```

'어떻게'가 아닌 '무엇을'에 집중하는 방식도 있다.
이전 스트림 API로 다음과 같은 질의를 만들 수 있었다.

```java
Optional<Transaction> mostExpensive = 
	transactions.stream()
		.max(comparing(Transaction::getValue));
```

질의문 구현 방법은 라이브러리가 결정한다. 이와 같은 구현 방식을 *** 내부 반복*** 이라고 한다.
질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다.

이처럼 '무엇을'에 집중하는 방식을 선언형 프로그래밍이라고 부른다. 
선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성한 것인지 등의 규칙을 정한다. 문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점이다.


#### 왜 함수형 프로그래밍인가?

함수형은 선언형을 따르는 대표적인 방식이며, 부작용이 없는 계산을 지향한다. 
위 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.

람다 표현식을 통해서 작업을 조합하거나 동작을 전달하는 등의 언어기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현하는데 많은 도움을 준다.
스트림으론 여러 연산을 연결해서 복잡한 질의를 표현할 수 있었다.

실제로 함수형 프로그래밍을 사용하고 자바8의 새로운 기능과 연결하려면 먼저 함수형 프로그래밍을 제대로 정의하고 자바로 어떻게 구현하는지 살펴봐야 한다. 함수형 프로그래밍을 이용하면 부작용이 없는 복잡하고 어려운 기능을 수행하는 프로그램을 구현할 수 있다.


### 함수형 프로그래밍이란 무엇인가?

'함수를 이용하는 프로그래밍이다'라고 답할 수 있다. 그럼 '함수란 무엇인가?'라는 질문이 다시 꼬리를 문다.

int와 double을 인수로 받아서 double을 반환하는 메서드가 있는데 이 메서드는 자신이 호출된 횟수로 가변 변수를 갱신하는 부작용을 포함하고 있다.

함수형 프로그래밍에서 함수란 수학적인 함수와 같다. 즉, 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 부작용이 없어야 한다. 
(side-effect없이 입력에 따른 출력만 수행, 동일한 입력에 대해서 동일한 출력을 반환, 솔직히 자바를 통한 복잡한 프로그래밍을 해보지 않아서 함수형 프로그래밍의 필요성을 충분히 인지하지 못한 상태로 이 책을 읽는 것에 대해서 아쉬움이 있다.)

자바와 같은 언어에서는 바로 수학적인 함수냐 아니냐가 메서드와 함수를 구분하는 핵심이다.
(log, sin 등의 수학적 함수는 절대 부작용을 포함하지 않을 것이다.)

***함수형***프로그래밍은 지금까지의 프로그래밍과는 사뭇 다른 모습일 것이다.
함수형 프로그래밍에선 함수 그리고 if-then-else등의 수학적 표현만 사용해야 하는가? 
아니면 시스템의 다른 부분에 ***영향을 미치지 않는다면*** 내부적으로 함수형이 아닌 기능도 사용할 수 있을까?
즉, 내부적으론 부작용이 발생하지만 호출자가 이를 알아차리지 못한다면 실제로 부작용이 발생한 것이라고 말할 수 있을까? 호출자에게 아무 영향을 미치지 않는다면 호출자는 내부적인 부작용을 파악하거나 신경쓸 필요가 없다.
결론적으로 '함수 그리고 if-then-else 등의 수학적 표현만 사용'하는 방식을 순수 함수형 프로그래밍이라고 하며 '시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용'하는 방식을 함수형 프로그래밍이라 한다.


#### 함수형 자바

실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 예를 들어 자바의 I/O 모델 자체에는 부작용 메서드가 포함된다(Scanner.nextLine을 호출하면 파일의 행을 소비한다. 즉, Scanner.nextLine을 두 번 호출하면 다른 결과가 반환될 가능성이 있다.)
하지만 시스템의 컴포넌트가 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수 있다.
자바에선 순수 함수형이 아니라 ***함수형 프로그래밍***을 구현할 것이다.
실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 함수형을 달성할 수 있다.
예를 들어 부작용을 일으키는 어떤 함수나 메서드가 있는데, 다만 진입할 때 어떤 필드의 값을 증가시켰다가 빠져나올 때 필드의 값을 돌려놓는다고 가정하자. 단일 스레드로 실행되는 프로그램의 입장에서는 이 메서드가 아무 부작용을 일으키지 않으므로 이 메서드는 함수형이라 간주할 수 있다. 하지만 다른 스레드가 필드의 값을 확인한다든가 아니면 동시에 이 메서드를 호출하는 상황이 발생할 수 있다면 이 메서드는 함수형이 아니다. 메서드의 바디를 잠금으로써 이 문제를 해결할 수 있으며 따라서 이 메서드는 함수형이라고 할 수 있다.
하지만 이런 식의 해결은 멀티코어 프로세서에서 메서드를 병렬로 호출할 수 없게 된다.
결국 부작용은 사라지지만 실행속도가 느려진다.

함수나 메서드는 ***지역 변수만***을 변경해야 함수형이라고 할 수 있다.
그리고 함수나 메서드에서 참조하는 객체가 있다면 불변 객체여야 한다.
예외적으로 메서드 내에서 생성한 객체의 필드는 갱신할 수 있다.
단 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 하고, 다음에 메서드를 다시 호출할 때 영향을 미치면 안된다.

함수형이라고 말할 수 있으려면 이 외에도 다른 조건을 만족해야 한다. 함수형이라면 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.
예외가 발생하면 return으로 결과 반환이 안되기 때문이다.
이러한 제약은 Optional을 통해 해결할 수 있다.
예외 없이도 결과값으로 연산을 성공적으로 수행했는지 아니면 요청된 연산을 성공적으로 수행하지 못했는지 확인할 수 있다.
즉, 호출자는 메서드 호출결과로 빈 Optional이 반환되는지 확인해야 한다.
이는 상당히 귀찮은 작업같다.
하지만 모든 코드가 Optional을 사용하도록 반드시 고쳐야 하는 것은 아니다.
함수형 프로그래밍과 순수 함수형 프로그래밍의 장단점을 실용적으로 고려해서 다른 컴포넌트에 영향을 미치지 않도록 지역적으로만 예외를 사용하는 방법도 고려할 수 있다.

함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.(즉, 먼저 자료구조를 복사한다든가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야 한다.)
이와 같은 설명을 주석으로 표현하거나 마커 어노테이션으로 메서드를 정의할 수 있다.
마커 어노테이션을 사용했다면 4장부터 7장까지 살벼본 Stream.map같은 병렬 스트림 처리 연산에 전달할 때 이와 같은 제약이 있는지 쉽게 확인할 수 있다.

우리가 만든 함수형 코드에서는 일종의 로그 파일로 디버깅 정보를 출력하도록 구현하는 것이 좋다.
물론 이처럼 디버깅 정보를 출력하는 것은 함수형 규칙에 위배되지만 로그 출력을 제외하고는 함수형 프로그래밍의 장점을 문제없이 누릴 수 있다.

#### 참조 투명성

'부작용을 감춰야 한다'라는 제약은 ***참조 투명성*** 개념으로 귀결된다. 즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.
("raoul".replace('r', 'R')이란 코드는 항상 같은 결과가 나오므로 String.replace는 참조적으로 투명하다. String.replace는 return this가 아니라 처리 후 새로운 String을 반환함.)

다시 말해, 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다.
따라서 Random.nextInt는 매번 다른 값이 호출되므로 함수형이 될 수 없다.
마찬가지로 Scanner객체로 사용자의 키보드 입력을 받는다면 참조 투명성을 위배한다.
nextLine 메서드를 호출했을 때 매번 다른 결과가 나올 수 있기 때문이다.
하지만 두 개의 final int변수를 더하는 연산에서는 두 변수를 바꿀 수 없으므로 이 연산은 항상 같은 결과를 생성한다.

참조 투명성은 프로그램 이해에 큰 도움을 준다. 또한 참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 기억화 또는 캐싱을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다. 이 기능이 중요하니 추후 설명한다.

자바에는 참조 투명성과 관련한 작은 문제가 있다. List를 반환하는 메서드를 두 번 호출한다고 가정하자. 두 번의 호출 결과로 같은 요소를 포함하지만 서로 다른 메모리 공간에 생성된 리스트를 참조할 것이다.
(각 List는 필드들은 같지만 메모리 주소가 다른 객체이다.)
결과 리스트가 가변 객체라면 (반환된 두 리스트가 같은 객체라 할 수 없으므로) 리스트를 반환하는 메서드는 참조적으로 투명한 메서드가 아니라는 결론이 나온다. 결과 리스트를 (불변의) 순수값으로 사용할 것이라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는 참조적으로 투명한 것으로 간주할 수 있다.
일반적으로 함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다. 

#### 객체지향 프로그래밍과 함수형 프로그래밍

먼저 함수형 프로그래밍과 기존의 익스트림 객체지향 프로그래밍을 비교하자.
사실 자바8은 함수형 프로그래밍을 익스트림 객체지향 프로그래밍의 일종으로 간주한다.
대부분의 자바 프로그래머는 무의식적으로 함수형 프로그래밍의 일부 기능과 익스트림 객체지향의 일부 기능을 사용할 것이다.
1장에서 설명한 것처럼(멀티코어 등의) 하드웨어 변경과 (데이터 베이스의 질의와 비슷한 방식으로 데이터를 조작하는 등의) 프로그래머의 기대치 때문에 결국 자바 소프트웨어 엔지니어의 프로그래밍 형식이 좀 더 함수형으로 다가갈 것이다.

|익스트림 객체지향 <-----------> 함수형 프로그래밍|
위 스펙트럼에서 중간에서 프로그래밍 할 것이다.
예를 들어 Iterator로 가변 내부 상태를 포함하는 자료구조를 탐색하면서 함수형 방식으로 자료구조에 들어 있는 값의 합계를 계산할 수 있다(이미 설명했듯이 자바에서는 지역 변수 변화가 수반될 수 있다.) 
모듈성이 좋고 멀티코어 프로세서에 적합한 프로그램을 구현하는 데 도움을 주는 함수형 프로그래밍의 기능을 소개하겠다.

#### 함수형 실전 연습

함수형을 처음 접하는 학생들에게 종종 제공되는 간단한 예제를 살펴보자. {1, 4, 9}처럼 List<Integer>가 주어졌을 때 이것의 모든 서브집합의 멤버로 구성된 List<List<Integer>>를 만드는 프로그램을 만든다고 가정하자. 예를 들어 {1, 4, 9}의 서브집합은 {1, 4, 9}, {1, 4}, {1, 9}, {4, 9}, {1}, {4}, {9}, {} 다.
빈 집합{}를 포함해서 총 8개의 서브집합이 존재한다. 
보통 '{1, 4, 9}의 서브집합 중 1을 포함하는 집합과 아닌 집합'으로 구분해서 문제를 풀려 시도할 것이다.
1을 포함하지 않는 부분집합은 {4, 9}의 부분집합이고, 1을 포함하는 부분집합은 {4, 9}의 모든 부분집합에 1을 포함시켜 얻을 수 있다. 이와 같은 접근 방식은 가장 쉽고, 자연스러운 함수형 함수형 자바 프로그래밍이다(여기서 가장 많이 하는 실수는 빈 리스트는 부분집합이 없다고 착각하는 것이다)

```java
static List<List<Integer>> subsets(List<Integer> list) {
	if (list.isEmpty()) {	//List가 비어있다면 비어있는 리스트를 하나 생성하여 반환
		List<List<Integer>> ans = new ArrayList<>();
		ans.add(Collections.emptyList());
		return ans;   //빈 리스트 자신이 서브집합이다.
	}			
	Integer first = list.get(0);    //첫 요소를 꺼냄.
	List<Integer> rest = list.subList(1, List.size());   //첫 요소제외한 여분
	
	//빈 리스트가 아니면 먼저 하나의 요소를 꺼내고 나머지 요소의 모든 서브집합을 찾아서 subans로 전달. subans는 절반의 정답을 포함한다.
	List<List<Integer>> subans = subsets(rest);   //여분을 가지고 재귀 수행
	
	//정답의 나머지 절반을 포함하는 subans2는 subans의 모든 리스트에서 처음 꺼낸 요소를 앞에 추가해서 만든다.
	List<List<Integer>> subans2 = insertAll(first, subans);  //첫 요소와 재귀수행한 여분을 합침
	return concat(subans, subans2);  //둘을 합침
}
```
입력으로 {1,4,9}를 제공하면 결과로 8개의 서브집합을 얻는다.
insertAll과 concat의 구현이 없다. 직접 완성하고 실행해 보자.

insertAll을 정의해보자. 첫 번째 함정이 나타났다.
만약 여러분이 insertAll의 인수를 변환하도록, 즉 subans의 모든 요소가 first를 포함하도록 인수를 변환했다고 가정하자. 결국 subans가 의도하지 않은 값을 포함하면서 이상한 결과가 나온다. (나도 단순하게 인자로 넘어온 subans에 first를 추가했음) 
다음처럼 insertAll을 정의해야 한다.


```java
static List<List<Integer>> insertAll(int first, List<List<Integer>> subans){

        List<List<Integer>> result = new ArrayList<>();
        for (List<Integer> list : subans) {
//리스트를 복사한 다음에 복사한 리스트에 요소를 추가한다. 
//구조체가 가변이더라도 저수준 구조를 복사하진 않는다. (Integer는 가변이 아니다.)
            List<Integer> copyList = new ArrayList<>();  
            copyList.add(first);
            copyList.addAll(list);
            result.add(copyList);
        }
        System.out.println("insertAll = " + result);
        return result;
}
```
subans의 모든 요소를 포함하는 새로운 List를 만들었다는 점에 주목하라. 여기선 Integer 객체가 불변이라는 사실을 이용했다(Integer가 불변이 아니라면 각 요소를 모두 복제해야 한다)
(불변 관련 내용 참조 : https://velog.io/@urtimeislimited/Java-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%97%90%EC%84%9C%EC%9D%98-%EB%B6%88%EB%B3%80%EC%84%B1#referenece)



마지막으로 concat 메서드를 정의한다. 다음은 간단하게 concat을 구현한 코드이므로 ***실무에선 사용하지 않도록 주의하자***.

```java
static List<List<Integer>> concat(List<List<Integer>> subans, List<List<Integer>> subans2) {
        subans.addAll(subans2);

        return subans;
}
```

다음처럼 구현하는 것이 바람직하다.

```java
static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b) {
        List<List<Integer>> r = new ArrayList<>(a);
	r.addAll(b);

        return r;
}
```

왜 두 번째 버전이 더 좋은 코드일까?
두 번째 버전의 concat은 순수 함수다.

내부적으로는 리스트 r에 요소를 추가하는 변화가 발생하지만 반환 결과는 오로지 인수에 의해 이루어지며 인수의 정보는 변경하지 않는다. 이와 달리 첫 번째 버전은 concat(subans, subans2)를 호출한 다음에 subans의 값을 다시 참조하지 않는다는 가정을 한다.(먼말이죠?)
실제로 우리 예제에선 subans의 값을 다시 참조하지 않으므로 더 가벼운 버전의 concat을 사용하는 것이 바람직하다. 각자의 상황에 따라 복제하는 것이 좋을지 잠재적인 버그를 찾기 위해 시간을 소비하는 것이 비용이 적을지 고려해서 어떤 방식을 선택할지 결정할 수 있다.(??!! 당연히 복제가 아닌가?)

'메서드의 첫 번째 인수를 임의의 값으로 바꿀 수 있는 상황에서만 메서드를 사용해야 하며 subsets를 고칠 때는 이 사실을 고려해야 함' 이라는 자세한 설명을 주석으로 추가했어도 여전히 누군가가 코드를 사용할 때는 이런 사실을 고려하기보다는 애초부터 끔찍한 디버깅 문제가 발생할 가능성이 없도록 구현된 코드를 선호할 것이다.

인수에 의해 출력이 결정되는 함수형 메서드의 관점에서 프로그램 문제를 생각하자. (즉, 무엇을 해야 하는가에 중점을 둔다)
이와 같은 방식으로 문제를 접근하면 설계 단계에서 어떻게 문제를 해결할 것이고 무엇을 변화할 것인지 결정하는 기존 방식에 비해 더 생산적일 때가 많다(설계 단계는 이와 같은 결정을 내리기에 너무 이른 상황이기 때문) 무엇을 해야 하는가에 집중할 수 있도록 도움을 주는 함수형 프로그래밍의 한 기법인 재귀를 좀 더 자세히 살펴보자.

### 재귀와 반복

순수 함수형 프로그래밍 언어에선 while, for 같은 반복문을 포함하지 않는다. 왜 그럴까?
이러한 반복문 때문에 변화가 자연스럽게 코드에 스며들 수 있기 때문이다. 
함수형 스타일에서는 다른 누군가가 변화를 알아차리지만 못한다면 아무 상관이 없다고 설명했다.
즉, 지역변수는 자유롭게 갱신할 수 있다.
다음은 자바의 Iterator로 for(Apple a : apples) {}라는 for-each 루프를 표현한 코드다.

```java
Iterator<Apple> it = apples.iterator();
while (it.hasNext) {
	Apple apple = it.next();
	//...
```

위 코드에서 호출자는 변화를 확인할 수 없으므로 아무 문제가 없다(즉, next로 Iterator의 상태를 변환했고, while 바디 내부에서 apple 변수에 할당하는 동작을 할 수 있다.) 하지만 다음 코드처럼 for-each루프를 사용하는 검색 알고리즘은 문제가 될 수 있다.

```java
public void searchForGold(List<String> l, Stats stats) {
	for (String s: l) {
		if("gold".equals(s)) {
			stats.incrementFor("gold");
		}
	}
}
```

(stats라는 loop 밖의 지역변수가 상태가 바뀌는 게 문제인건가?)

루프의 바디에서 함수형과 상충하는 부작용이 발생한다. 즉, 루프 내부에서 프로그램의 다른 부분과 공유되는 stats 객체의 상태를 변화시킨다.

이러한 문제 때문에 하스켈 같은 순수 함수형 프로그래밍 언어에서는 부작용 연산을 원천적으로 제거했다.
(그럼 for문이 없나? 그런가봄 하스켈에선 반복을 재귀를 사용하나 봄, 나중에 찾아봐야지)
그럼 어떻게 프로그램을 구현하나? 이론적으로 반복을 이용하는 모든 프로그램은 재귀로도 구현할 수 있는데 재귀를 이용하면 변화가 일어나지 않는다. 재귀를 이용하면 루프 단계마다 갱신되는 반복 변수를 제거할 수 있다. 다음은 팩토리얼 함수로, 반복과 재귀방식으로 해결할 수 있는 고전적 학교문제다. 여기서 입력은 1보다 크다고 가정한다.

반복 방식의 팩토리얼

1* 2* 3* 4

``java
static int factorialIterative(int n) {
	int r = 1;
	for (int i = 1; i <= n; i++) {
		r *= i;
	}
	return r;
}
```

재귀방식의 팩토리얼

```java
static long factorialRecursive(long n) {
	return (n == 1) ? 1 : n * factorialRecursive(n-1);
}
```

첫째 예제는 일반적인 루프를 사용한 코드로 매 반복마다 변수 r과 i가 갱신된다.
둘째 예제는 재귀(자신을 호출) 방식의 코드로 좀 더 수학적인 형식으로 문제를 해결한다.

자바8 스트림을 통해 더 단순한 팩토리얼을 정의해보자.

스트림 팩토리얼

```java
static long factorialStream(long n) {
	return LongStream.rangeClosed(1, n)
			.reduce(1, (long a, long b) -> a * b);
}
```

이제 효율성 측면을 살펴보자.
함수형 프로그래밍의 장점이 분명히 있지만 무조건 반복보다는 재귀가 좋다고 주장하는 함수형 프로그래밍 광신도의 주장에 주의해야 한다.
일반적으로 반복코드보다 재귀 코드가 더 비싸다.
왜 그럴까?(함수를 호출할 때마다 변수 메모리를 확보하기 때문에)
factorialRecursive 함수를 호출할 때마다 호출 스택에 각 호출시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어진다.
즉 재귀 팩토리얼의 입력값에 비례해서 메모리 사용량이 증가한다. 따라서 큰 입력값을 사용하면 다음처럼 StrackOverflowError가 발생한다.

Exception in thread "main" java.lang.StackOverflowError

그러면 재귀는 쓸모없는 것인가? 그렇지 않다.
함수형 언어에서는 꼬리 호출 최적화라는 해결책을 제시한다.
(꼬리 호출 최적화? tail-call optimization, 메모이제이션 같은 건가?)

꼬리 재귀 팩토리얼

```java
static long factorialTailRecursive(long n) {
	return factorialHelper(1, n);
}
static long factorialHelper(long acc, long n) {
	return n == 1 ? acc : factorialHelper(acc * n, n-1);
}
```
factorialHelper에서 재귀 호출이 가장 마지막에서 이루어지므로 꼬리 재귀다. 
반면 이전 factorialRecursive에서 마지막으로 수행한 연산은 n과 재귀 호출의 결과값의 곱셈이다.

중간 결과를 각각의 스택프레임으로 저장해야 하는 일반 재귀와 달리 꼬리 재귀에서는 컴파일러가 하나의 스택 프레임을 재활용할 가능성(가능성??언제 재활용하는지 알 수는 없나?)이 생긴다.
사실 factorialHelper의 정의에서는 중간 결과(팩토리얼의 부분결과)를 함수의 인수로 직접 전달한다.
(1~n의 순차적 인자 뿐만 아니라 그 인자를 사용한 함수의 결과 또한 다음 재귀함수의 인자로 활용된다.)

안타깝게도 자바는 이와 같은 최적화를 제공하지 않는다.
그럼에도 여전히 고전적인 재귀보다는 여러 컴파일러 최적화 여지를 남겨둘 수 있는 꼬리 재귀를 적용하는 것이 좋다.
스칼라, 그루비 같은 최신 JVM 언어는 이와 같은 재귀를 반복으로 변환하는 최적화를 제공한다(속도의 손실이 없이). 결과적으로 순수 함수형을 유지하면서도 유용성 뿐 아니라 효율성까지도 잡을 수 있다.

결론적으로 자바 8에선 반복을 스트림으로 대체해서 변화를 피할 수 있다.
(모든 것을 스트림으로 해야 하는가?)
또한 반복을 재귀로 바꾸면 더 간결하고 부작용 없는 알고리즘을 만들 수 있다.
실제로 재귀를 이용하면 쉽게 읽고 쓰고 이해할 수 있는 예제를 만들 수 있다.
약간의 실행차이 보단 프로그래머의 효율성이 더 중요할 때도 많다.


---

# 함수형 프로그래밍 기법

### 함수는 모든 곳에 존재한다

함수형 프로그래밍이란 함수나 메서드가 순수함수처럼 동작함을 의미(부자용 없이)
함수형 프로그래밍에선 함수를 마치 일반값처럼 사용해서 인수로 전달하거나 결과로 반환받거나 자료구조에 저장할 수 있다. 
일반값처럼 취급할 수 있는 함수를 ***일급 함수***라고 한다.
자바8이전버전과 구별되는 특징 중 하나가 일급 함수를 지원한다는 점이다.
자바8에선 ::연산자로 메서드 참조를 만들거나 (int x)-> x + 1 같은 람다 표현식으로 직접 함숫값을 표현해서 메서드를 함숫값으로 사용할 수 있다. 자바8은 다음과 같은 메서드 참조로 Integer.parseInt를 저장할 수 있다.
```java
Function<String, Integer> strToInt = Integer::parseInt;
```

#### 고차원 함수

지금까지 함숫값을 자바8 스트림 처리 연산으로 전달(4~7장)하거나 filterApples에 함숫값으로 Apple::isGreenApple을 전달해서 동작 파라미터화를 달성(1~2장)하는 용도로만 사용했다. 이는 함숫값 활용의 일부에 불과하다.
함수를 인수로 받아서 다른 함수로 반환하는 정적 메서드 Comparator.comparing도 있었다.

```java
Comparator<Apple> c = comparing(Apple::getWeight);
```

3장에서는 함수를 조립해서 연산 파이프라인을 만들 때 위 코드와 비슷한 기능을 활용했다.

```java
Function<String, String> transformationPipeline = addHeader.andThen(Letter::checkSpelling).andThen(Letter::addFooter);
```

함수형 프로그래밍 커뮤니티에 따르면 Comparator.comparing처럼 다음 중 하나 이상의 동작을 수행하는 함수를 ***고차원 함수***라 부른다.
- 하나 이상의 함수를 인수로 받음.
- 함수를 결과로 반환

자바8에선 함수를 인수로 전달할 수 있을 뿐 아니라 결과로 반환하고, 지역 변수로 할당하거나, 구조체로 삽입할 수 있으므로 자바8의 함수도 고차원 함수라고 할 수 있다.
예를 들어 계산기에서 문자열 'sin'을 Function<Double, Double>로 매핑하는 Map<String, Function<Double, Double>>이 있다고 가정하자(최종적으로 Math::sin을 획득)


Function<Function<Double,Double>, Function<Double,Double>>

예를 들어 위 함수는 (Double x) -> x * x라는 함수를 인수로 받아 (Double x) -> 2 * x 같은 함수를 결과로 반환한다. 결과가 함수 형식(가장 왼쪽의 Function)이므로 미분 함수를 다른 함수로 다시 전달할 수 있다. 다음의 미분 형식과 시그니처는 결국 위 함수와 같다.

Function<Double,Double> differentiate(Function<Double,Double> func)


부작용과 고차원 함수

스트림 연산으로 전달하는 함수는 부작용이 없어야 하며, 부작용을 포함하는 함수를 사용하면 문제가 생긴다.(부작용을 포함하는 함수를 사용하면 부정확한 결과가 발생하거나 레이스 컨디션 때문에 예상치 못한 결과가 발생) 고차원 함수를 적용할 때도 같은 규칙이 적용된다.
고차원 함수나 메서드를 구현할 때 어떤 인수가 전달될지 알 수 없으므로 인수가 부작용을 포함할 가능성을 염두에 둬야 한다.(함수들이 어떻게 연결되는지 함수명만으로 파악이 힘들다는 소리 같음. 근데 OOP로 추상화 하는 것 자체가 그런거지 않나 싶음.)
함수를 인수로 받아 사용하면서 코드가 정확히 어떤 작업을 수행하고 프로그램의 상태를 어떻게 바꿀지 예측하기 어려워진다. 디버깅도 어려워질 것이다. 따라서 인수로 전달된 함수가 어떤 부작용을 포함하게 될지 정확하게 문서화하는 것이 좋다. 물론 부작용을 포함하지 않을 수 있다면 가장 좋을 것이다.(다른 사람과 같이 작업 한다면 혹은 본인이 실수할 수도 있어서 부작용을 포함하지 않는다는 보장이 없기 때문에 문서화가 필요할 듯)

이제 함수를 모듈화하고 코드를 재사용하는 데 도움을 주는 기법인 커링을 살펴보자.


#### 커링

국제화 예제를 먼저 살펴보자. 국제화는 단위 변환 문제가 발생할 수 있다.

보통 변환 요소와 기준치 조정 요소가 단위 변환 결과를 좌우한다.

예시) 섭씨를 화씨로 변환하는 공식

CtoF(x) = x*9/5 + 32

다음과 같은 패턴으로 단위를 표현할 수 있다.
1. 변환요소를 곱함
2. 기준치 조정 요소를 적용

다음과 같은 메서드로 변환 패턴을 표현할 수 있다.

```java
static double convertor(double x, double f, double b) {
	return x * f + b;
}
```
x는 변환하려는 값이고, f는 변환 요소며, b는 기준치 조정 요소다.
세 개의 인수를 받는 converter라는 메서드를 만들어 문제를 해결하는 방법도 있지만 인수에 변환 요소와 기준치를 넣는 일은 귀찮고 오타 발생우려도 있다.

각각 변환하는 메서드를 따로 만들면 로직을 일반화 하지 못해서 재활용이 안된다.

기존 로직을 활용해서 변환기를 특정 상황에 적용할 수 있는 방법이 있다.
다음은 커링이라는 개념을 활용해서 한 개의 인수를 갖는 변환 함수를 생산하는 '팩토리'를 정의하는 코드다.

```java
static DoubleUnaryOperator curriedConverter(double f, double b) {
	return (double x) -> x * f + b;
}
```
위 메서드에 변환요소(f)와 기준치(b)만 넘겨주면 우리가 원하는 작업을 수행할 함수가 반환된다.
예를 들어 다음은 팩토리를 이용해서 원하는 변환기를 생성하는 코드다.


```java
DoubleUnaryOperator convertCtoF = curriedConverter(9.0/5, 32);
DoubleUnaryOperator convertUSDtoGBP = curriedConverter(0.6, 0);
DoubleUnaryOperator convertKtoM = curriedConverter(0.6214, 0);
```

DoubleUnaryOperator는 applyAsDouble이라는 메서드를 정의하므로 다음처럼 변환기를 사용할 수 있다.

double gbp = convertUSDtoGBP.applyAsDouble(1000);

결과적으로 기존의 변환 로직을 재활용하는 유연한 코드를 얻었다. 우리가 어떤 작업을 했는지 다시 생각해보자. x, f, b라는 세 인수를 converter 메서드로 전달하지 않고 f, b 두 가지 인수로 함수를 요청했으며 반환된 함수에 인수 x를 이용해서 x * f + b라는 결과를 얻었다. 이런 방식으로 변환 로직을 재활용할 수 있으며 다양한 변환 요소로 다양한 함수를 만들 수 있다.


커링의 이론적 정의(커링이란 가죽의 유연성을 높이기 위해 가죽을 가지제로 처리하는 일)

커링은 x와 y라는 두 인수를 받는 함수 f를 한 개의 인수를 받는 g라는 함수로 대체하는 기법이다.
이때 g라는 함수 역시 하나의 인수를 받는 함수를 반환한다. 함수g와 원래 함수 f가 최종적으로 반환하는 값은 같다. 즉, f(x,y) = (g(x))(y)가 성립한다.

물론 이 과정을 일반화할 수 있다. 여섯 개의 인수를 가진 함수를 커리해서 우선 2,4,6번째 인수를 받아 5번째 인수를 받는 함수를 반환하고 다시 이 함수는 남은 1,3번째 인수를 받는 함수를 반환한다.

이와 같은 여러 과정이 끝까지 완료되지 않은 상태를 가리켜 '함수가 부분적으로 적용되었다'라고 말한다.


#### 영속 자료구조

이 절에서는 함수형 프로그램에서 사용하는 자료구조를 살펴본다. 
함수형 프로그램에서는 함수형 자료구조, 불변 자료구조 등의 용어도 사용하지만 보통은 영속 자료구조라고 부른다('영속persistent'이라는 단어는 데이터베이스에서 프로그램 종료 후에도 남아있음을 의미하는 영속과는 다른 의미다.)

함수형 메서드에서는 전역 자료구조나 인수로 전달된 구조를 갱신할 수 없다. 왜 그럴까? 자료구조를 바꾼다면 같은 메서드를 두 번 호출했을 때 결과가 달라지면서 참조 투명성에 위배되고 인수를 결과로 단순하게 매핑할 수 있는 능력이 상실되기 때문이다.

##### 파괴적인 갱신과 함수형

자료구조를 갱신할 때 발생할 수 있는 문제를 확인해보자. A에서 B까지 기차여행을 의미하는 ***가변***TrainJourney 클래스가 있다고 가정하자. TrainJourney는 간단한 단방향 연결리스트로 구현되며 여행 구간의 가격 등 상세 정보를 포함하는 int 필드를 포함한다. 다음 코드에서 보여주는 것처럼 기차여행에서는 
여러 TrainJourney 객체를 연결할 수 있는 onward(이어지는 여정을 의미)라는 필드가 필요하다. 직통열차나 여정의 마지막 구간에서는 onward가 null이 된다.

```java
class TrainJourney {
	public int price;
	public TrainJourney onward;
	public TrainJourney(int p, TrainJourney t) {
		price = p;
		onward = t;
	}
}
```
이때 X에서 Y까지 그리고 Y에서 Z까지의 여행을 나타내는 별도의 TrainJourney 객체가 있다고 가정.
아마 두 개의 TrainJourney 객체를 연결해서 하나의 여행을 만들 수 있을 것이다.(X -> Y -> Z)

기존의 단순한 명령형 메서드라면 다음처럼 기차여행을 연결할 것이다.
```java
static TrainJourney link(TrainJourney a, TrainJourney b) {
	if (a == null) return b;
	TrainJourney t = a;
	while(t.onward != null) {
		t = t.onward;
	}
	t.onward = b;
	return a;
```

위 코드는 a의 TrainJourney에서 마지막 여정을 찾아 a의 리스트 끝 부분을 가리키는 null을 리스트 b로 대체한다(a가 아무 요소도 포함하지 않는 상황은 따로 고려해야 한다.) 
여기서 문제가 발생한다.
firstJourney라는 변수는 X에서 Y로의 경로를 포함하고, secondJourney라는 변수는 Y에서 Z로의 경로를 포함한다. link(firstJourney, secondJourney)를 호출하면 firstJourney가 secondJourney를 포함하면서 파괴적인 갱신(즉, firstJourney를 변경시킴)이 일어난다.
결과적으로 firstJourney의 변수는 X에서 Y가 아닌 X에서 Z로의 여정을 의미하게 된다.
이렇게 되면 firstJourney에 의존하는 코드가 동작하지 않게 된다.
firstJourney가 서울역에서 구미역까지의 기차여정이었는데 갑자기 서울역에서 구미역을 지나 부산역까지 도착하는 여정으로 바뀐다면 firstJourney를 참고하던 사용자는 혼란에 빠질 것이다. 이렇게 자료구조를 바꾸면서 생기는 버그를 어떻게 처리할 것인지 문제를 해결해야 한다.(자료구조를 바꾼다는 게 필드를 추가한다 던게 아니라 필드에 있던 정보가 바뀌는 것을 의미하나 봄)

함수형에서는 이 같은 부작용을 수반하는 메서드를 제한하는 방식으로 문제를 해결한다.
계산 결과를 표현할 자료구조가 필요하면 기존의 자료구조를 갱신하지 않도록 새로운 자료구조를 만들어야 한다.
이는 표준 객체지향 프로그래밍의 관점에서도 좋은 기법이다. 함수형을 따르지 않는 프로그램의 문제 중 하나는 부작용을 포함하는 코드와 관련하여 '이 점을 기억해야 함', '문서화해둠' 같은 주석을 프로그래머가 과도하게 남용할 수 있다는 것이다.
이 같은 주석은 나중에 코드를 유지보수하는 프로그래머를 괴롭힌다.
따라서 다음처럼 깔끔한 함수형 해결방법을 사용하는 것이 좋다.

```java
static TrainJourney append(TrainJourney a, TrainJourney b) {
	return a == null ? b : new TrainJourney(a.price, append(a.onward, b)); //재귀사용
```

이 코드는 명확하게 함수형이며 기존 자료구조를 변경하지 않는다(전역 심지어 지역적인 변화도 일어나지 않는다). 하지만 TrainJourney 전체를 새로 만들지 않는다. a가 n요소의 시퀀스고 b가 m요소의 시퀀스라면 n+m요소의 시퀀스를 반환한다. 여기서 첫 번째 n요소는 새로운 노드며 마지막 m 요소는 TrainJourney b와 공유되는 요소다. 주의할 점은 사용자 역시 append의 결과를 갱신하지 말아야 한다는 것이다. 만약 append의 결과를 갱신하면 시퀀스 b로 전달된 기차 정보도 바뀐다. 


#### 트리를 사용한 다른 예제

이번에는 다른 자료구조를 살펴보자. HashMap 같은 인터페이스를 구현할 때는 이진 탐색 트리가 사용된다.
Tree는 문자열 키와 int 값을 포함한다.
예를 들어 이름 키와 나이 정보값을 포함할 수 있다.

```java
class Tree {
	private String key;		//키는 문자열
	private int val;		//값은 int
	private Tree left, right;	//트리로 왼쪽, 오른쪽
	public Tree(String k, int v, Tree l, Tree r) {		//트리는 키,값,왼,오 입력
		key = k; val = v; left = l; right = r;
	}
}

class TreeProcessor {
	public static int lookup(String k, int defaultval, Tree t) {  //찾기, 키랑 기본값
		if (t == null) return defaultval; //t가 null이면 기본값을 반환해라
		if (k.equals(t.key)) return t.val; //k키랑 t의 키가 같다면 t의 값을 반환
		return lookup(k, defaultval,
				//재귀 이진 탐색으로 최종 트리까지 타고 내려감.
				k.compareTo(t.key) < 0 ? t.left : t.right); 
	}
	//트리의 다른 작업을 처리하는 기타 메서드
}
```

이제 이진 탐색 트리를 이용해서 문자열값으로 int를 얻을 수 있다.
주어진 키와 연관된 값을 어떻게 갱신할 수 있는지 살펴보자(우리가 찾으려는 키가 트리에 존재한다고 가정)

```java
public static void update(String k, int newval, Tree t) {
	if (t == null) { /* 새로운 노드를 추가해야 함 */ }
	else if (k.equals(t.key)) t.val = newval;
	else update(k, newval, k.compareTo(t.key) < 0 ? t.left : t.right);
}
```

새로운 노드를 추가할 때는 주의해야 한다. 가장 쉬운 방법은 update 메서드가 탐색한 트리를 그대로 반환하는 것이다(새로운 노드를 추가하지 않으면 기존 트리가 그대로 반환된다).
하지만 이 방법은 그리 깔끔하지 못하다(사용자는 update가 즉석에서 트리를 갱신할 수 있으며, 전달한 트리가 그대로 반환된다는 사실, 원래 트리가 비어있으면 새로운 노드가 반환될 수 있다는 사실을 모두 기억해야 하기 때문이다).

```java
public static Tree update(String k, int newval, Tree t) {
	if (t == null) 
		t = new Tree(k, newval, null, null); //비어있다면 키, 값대로 루트 추가
	else if (k.equals(t.key))	//키가 같다면 t값을 갱신
		t.val = newval;
	else if (k.compareTo(t.key) < 0)  //키를 비교해서 작으면 왼쪽 크면 오른쪽 트리로 이동
		t.left = update(k, newval, t.left);
	else
		t.right = update(k, newval, t.right);
	return t;
```
두 가지 update 버전 모두 기존 트리를 변경한다. 즉, 트리에 저장된 맵의 모든 사용자가 변경에 영향을 받는다.
(재귀로 풀긴 하지만 t를 수정하기 때문에 기존 트리를 변경함)

#### 함수형 접근법 사용

이 문제를 함수형으로 어떻게 처리할 수 있을까?
우선 새로운 키/값 쌍을 저장할 새로운 노드를 만들어야 한다.
또한 트리의 루트에서 새로 생성한 노드의 경로에 있는 노드들도 새로 만들어야 한다(보통 노드를 새로 만드는 동작은 생각보다 비싸지 않은 편이다. d라는 깊이를 갖는 트리고 균형이 어느 정도 잡혀있다면 2^d 만큼의 개체를 가지고 있으므로 재생성 과정은 그중 일부 노드를 생성하는 과정에 불과하다)

??이렇게 사용하기 빡세면 함수형 프로그래밍 어떻게 함. 이것도 나중에 적응되면 익숙해져서 쉽게 할 수 있을까?

```java
public static Tree fupdate(String k, int newval, Tree t) {
	return (t == null) ?
		new Tree(k, newval, null, null) :
			k.equals(t.key) ?
				new Tree(k, newval, t.left, t.right) :
			k.compareTo(t.key) < 0 ?
				new Tree(t.key, t.val, fupdate(k, newval, t.left), t.right) :
				new Tree(t.key, t.val, t.left, fupdate(k, newval, t.right));
}
```


위 코드에서는 if-then-else 대신 하나의 조건문을 사용했는데 이렇게 해서 위 코드가 부작용이 없는 하나의 표현식임을 강조했다. 하지만 취향에 따라 if-then-else문으로 코드를 구현할 수 있다.

update와 fupdate의 차이는 뭘까? 이전에 update 메서드는 모든 사용자가 같은 자료구조를 공유하며 프로그램에서 누군가 자료구조를 갱신했을 때 영향을 받는다는 점을 설명했다.
따라서 비함수형 코드에서는 누군가 언제든 트리를 갱신할 수 있으므로 트리에 어떤 구조체의 값을 추가할 때마다 값을 복사했다. 반면 fupdate는 순수한 함수형이다. fupdate에서는 새로운 Tree를 만든다.
하지만 ***인수를 이용해서 가능한 한 많은 정보를 공유한다.***(??먼말이지??)
사람의 이름과 나이를 노드로 저장하는 트리를 만들었다고 가정하자. 여기서 fupdate를 호출하면 기존의 트리를 갱신하는 것이 아니라 새로운 노드를 만든다.

이와 같은 함수형 자료구조를 영속(저장된 값이 다른 누군가에 의해 영향을 받지 않는 상태)이라고 하며 따라서 프로그래머는 fupdate(뭔가 했더니 함수형 업데이트구만)가 인수로 전달된 자료구조를 변화시키지 않을 것이라는 사실을 확신할 수 있다. ***'결과 자료구조를 바꾸지 말라'***는 것이 자료구조를 사용하는 모든 사용자에게 요구하는 단 한가지 조건이다. 이를 무시하고 fupdate의 결과를 바꾸는 사람도 있을 것이다(예를 들어 Emily의 20을 다른 숫자로 바꿈).  결과 자료구조를 바꾸지 말라는 조건을 무시한다면 fupdate로 전달된 자료구조에 의도치 않은 그리고 원치 않는 갱신이 일어난다.
fupdate가 좀 더 효율적일 때가 많다. '기존 구조를 변화시키지 않는다'라는 법칙 덕분에 조금 다른 구조체(예를 들어 사용자 A가 확인하는 트리와 사용자 B가 확인하는 갱신된 버전처럼) 간의 공통부분을 공유할 수 있다는 점에서 다른 구조체와 조금 다르다.
Tree 클래스의 key, val, left, right 필드를 final로 선언함으로써 '기존 구조를 변화시키지 않는다'는 규칙을 강제할 수 있다. 하지만 final은 필드에만 적용되며 객체에는 적용되지 않으므로 각 객체의 필드에 final을 적절하게 사용해야 함을 기억하자.

어떤 사람은 '나는 일부 사용자만 볼 수 있게 트리를 갱신하면서도 다른 일부 사용자는 이를 알아차릴 수 없게 하고 싶다'고 말한다.
두 가지 방법이 있다.
하나는 고전적인 자바 해법이다(어떤 값을 갱신할 때 먼저 복사해야 하는지 주의 깊게 확인).
다른 하나는 함수형 해법이다.
즉, 갱신을 수행할 때마다 논리적으로 새로운 자료구조를 만든 다음에(변화가 일어나지 않도록) 사용자에게 적절한 버전의 자료구조를 전달할 수 있다. 
API로 이 방법을 강제할 수 있다. 자료구조의 고객이 볼 수 있도록 갱신을 수행해야 한다면 최신 버전을 반환하는 API를 사용할 수 있다.  반면에 보이지 않도록 갱신을 수행해야 한다면, 예를 들어 오래 실행되는 통계분석 같은 경우에는 변화가 일어나지 않도록 단순히 인수를 복사한 값을 반환하면 된다.

이 기법은 레이저로 단 한 번 CD-R에 파일을 '갱신'하는 동작과 비슷하다. 여러 파일의 버전을 모두 CD에 저장했다가 적잘한 파일 시작 주소 블록을 전달할 수 있다(스마트 CD 젲가 소프트웨어라면 여러 파일 버전의 공통 부분을 공유하는 기능을 제공할 수도 있다). 자바는 CD보단 상황이 좋다. 자바에서 자료구조의 예전 버전은 적어도 자동으로 가비지 컬렉트되기 때문이다.
(?솔직히 이번 파트는 무슨 소린지 잘 이해가 되지 않음. 대충 추상적으로 의미만 파악함.)


### 스트림과 게으른 평가

스트림은 데이터 컬렉션을 처리하는 편리한 도구임을 살펴봤다. 효율적인 구현 및 여러 이유로 자바8 설계자들은 스트림을 조금 특별한 방법으로 자바8에 추가했다. 그중 하나로 스트림은 단 한 번만 소비할 수 있다는 제약이 있어서 스트림은 재귀적으로 정의할 수 없다. 이 절에서는 이와 같은 제약 때문에 어떤 문제가 발생하는지 살펴볼 것이다.(그러네 스트림은 한 번만 사용하니까 함수형으로 못하는 구나. 나는 스트림을 사용하는 게 함수형 프로그래밍의 일부분이라고 생각했는데 아니네?)

#### 자기 정의 스트림

소수를 생성하는 6장의 예제로 재귀 스트림을 살펴보자. 다음 코드처럼 소수 스트림을 계산할 수 있었다.

```java
public static Stream<Integer> primes(int n) {
	return Stream.iterate(2, i -> i + 1)	//반복자 2 부터 스트림 생성
		.filter(MyMathUtils::isPrime)
		.limit(n);
}

public static boolean isPrime(int candidate) {
	int candidateRoot = (int) Math.sqrt((double) candidate);
	return IntStream.rangeClosed(2, candidateRoot)
			.noneMatch(i -> candidate % i == 0);
}
```
추가적으로 candidate number로 정확히 나누어 떨어지는지 매번 모든 수를 반복 확인했다.(실제로 합성수=서로 다른 두 개 이상의 소수의 곱으로 이루어진 수, 는 나누어 떨어지는지 확인할 필요가 없다)
이론적으로 소수로 나눌 수 있는 모든 수는 제외할 수 있다.

결국 소수의 배수라면 제외해도 됨.

다음은 소수로 나눌 수 있는 수를 제외하는 과정을 설명한다.

1. 소수를 선택할 숫자 스트림이 필요하다.
2. 스트림에서 첫 번째 수(스트림의 머리)를 가져온다. 이 숫자는 소수다(처음은 2)
3. 이제 스트림의 꼬리에서 가져온 수로 나누어 떨어지는 모든 수를 걸러 제외시킨다.
4. 이렇게 남은 숫자만 포함하는 새로운 스트림에서 소수를 찾는다. 이제 1번부터 다시 이 과정을 반복하게 된다. 따라서 이 알고리즘은 재귀다.

이 알고리즘은 여러 가지 면에서 '부족한' 알고리즘이다. 다만 스트림이 어떻게 동작하는지 쉽게 보여줄 수 있는 좋은 간단한 알고리즘이다. 스트림 API로 이 알고리즘을 구현해보자.

*** 1단계 : 스트림 숫자 얻기 ***
IntStream.iterate 메서드를 이용하면 2에서 시작하는 무한 숫자 스트림을 생성할 수 있다.
```java
static IntStream numbers() {
	return IntStream.iterate(2, n -> n + 1);
}
```
*** 2단계 : 머리 획득 ***
IntStream은 첫 번째 요소를 반환하는 findFirst라는 메서드를 제공한다.
```java
static int head(IntStream numbers) {
	return numbers.findFirst().getAsInt();
}
```

*** 3단계 : 꼬리 필터링 ***

스트림의 꼬리를 얻는 메서드를 정의한다.

```java
static IntStream tail(IntStream nubmers) {
	return numbers.skip(1);		//처음 1개의 스트림요소(head)을 버리고 반환
}
```

다음처럼 획득한 머리로 숫자를 필터링할 수 있다.
```java
IntStream numbers = numbers();	//
int head = head(numbers);
IntStream filtered = tail(numbers).filter(n -> n % head != 0);
```

*** 4단계 : 재귀적으로 소수 스트림 생성 ***

가장 어려운 부분이다. 다음 코드에서 보여주는 것처럼 반복적으로 머리를 얻어서 스트림을 필터링하려 할 수 있다.

```java
static IntStream primes(IntStream numbers) {
	int head = head(numbers);
	return IntStream.concat(
		IntStream.of(head),
		primes(tail(numbers).filter(n -> n % head != 0))  //2, 
	);
}
```

***나쁜 소식***

안타깝게도 4단계 코드를 실행하면 "java.lang.IllegalStateException: stream has already been operated upon or closed"라는 에러가 발생한다. 사실 우리는 스트림을 머리와 꼬리로 분리하는 두 개의 최종연산 findFirst와 skip을 사용했다. 4장에선 최종연산을 스트림에 호출하면 스트림이 완전 소비된다는 사실을 증명했다.


***게으른 평가***

위 나쁜 소식보다 더 심각한 문제가 있다. IntStream.concat은 두 개의 스트림 인스턴스를 인수로 받는다. 두 번째 인수가 primes를 직접 재귀적으로 호출하면서 무한 재귀에 빠진다. '재귀적 정의 허용하지 않음'같은 자바8의 스트림 규칙은 우리에게 아무 해도 끼치지 않으며 오히려 이 규칙 덕분에 데이터베이스 같은 질의를 표현하고 병렬화할 수 있는 능력을 얻을 수 있다. 그래서 자바8 설계자는 이 같은 제한을 두기로 결정했다. 사실 스칼라, 하스켈 같은 함수형 언어에서는 자바8에 비해 좀 더 일반적인 기능과 모델을 제공한다. 결론적으로 concat의 두 번째 인수에서 primes를 게으르게 평가하는 방식으로 문제를 해결할 수 있다(좀 더 기술적인 프로그래밍 언어의 용어로는 게으른 평가 비엄격한 평가 또는 이름에 의한 호출이라 한다)
즉 소수를 처리할 필요가 있을 때만 스트림을 실제로 평가한다. 스칼라에서도 이와 같은 기능을 제공한다.
다음 예제는 스칼라로 알고리즘을 구현한 코드다. 여기서 #:: 연산자는 게으른 연결을 담당한다.(즉 실제 스트림을 소비해야 하는 상황이 되었을 때 인수를 평가한다.)

```scala
def numbers(n: Int): Stream[Int] = n #:: numbers(n+1)

def primes(numbers: Stream[Int]): Stream[Int] = {
numbers.head #:: primes(numbers.tail filter (n -> n % numbers.head != 0))
}
```

위 코드는 자바와 다른 함수형 언어가 어떻게 다른지 보여주는 것뿐 코드를 이해하기 어렵다 걱정할 필요없다.
인수가 어떻게 평가되는지 살펴보자.
자바에서는 메서드를 호출하면 모든 인수가 즉시 평가된다.(즉시 평가된다는 게 뭐지?)
하지만 스칼라에서는 #:: 을 사용한 연결식이 즉시 반환될 뿐이며 필요한 시점이 되어서야 각 요소가 평가된다.
이제 자바로 게으른 리스트 평가를 구현하는 방법으로 되돌아가자.

#### 게으른 리스트 만들기

'자바8의 스트림은 게으르다'라는 설명을 들어봤을 것이다.(한 번도 안들어봤음 스트림 자체를 첨써봐서...)
자바8의 스트림은 요청할 때만 값을 생성하는 블랙박스와 같다.
스트림에 일련의 연산을 적용하면 연산이 수행되지 않고 일단 저장된다.
스트림에 최종연산을 적용해서 실제 계산을 해야하는 상황에서만 실제 연산이 이루어진다.
특히 스트림에 여러 연산(filter, map, reduce 등)을 적용할 때 이와 같은 특성을 활용할 수 있다.
게으른 특성 때문에 각 연산별로 스트림을 탐색할 필요 없이 한 번에 여러 연산을 처리할 수 있다.
(이게 먼말이야??)

이 절에선 좀 더 일반적인 스트림의 형태인 게으른 리스트의 개념을 살펴본다.(게으른 리스트는 스트림과 비슷한 개념으로 구성된다.)
또한 게으른 리스트는 고차원 함수라는 개념도 지원한다.(고차원 함수란 함수를 반환하거나 함수를 인자로 사용하는 함수였던 것 같은데)
함숫값을 자료구조에 저장해서 함숫값을 사용하지 않은 상태로 보관할 수 있다.
하지만 저장한 함숫값을 호출(즉, 요청)하면 더 많은 자료구조를 만들 수 있다.

LinkedList의 요소는 메모리에 존재함. 하지만 LazyList의 요소는 Function이 요청해야 생성됨.

LinkedList ■ ---꼬리---> ■ ---꼬리---> ■

LazyList    ■ ---함수--->  □ ---함수---> □

백문이 불여일견, 게으른 리스트가 실제로 동작하는 모습을 살펴보자. 이전에 설명한 알고리즘에서 무한한 소수 리스트를 생성해야 한다.


####기본적인 연결 리스트

다음 코드처럼 MyLinkedList라는 단순한 연결 리스트 형태의 클래스를 정의할 수 있다(예제 코드에선 필요한 최소 기능만 정의하는 MyList 인터페이스를 정의)

```java
interface MyList<t> {
	T head();		//첫 요소
		
	MyList<T> tail();	//첫 요소를 제외한 나머지 요소 리스트

	default boolean isEmpty() {	//디폴트 메서드로 비었는지 확인
		return true;
	}
}

class MyLinkedList<T> implements MyList<T> {
	private final T head;
	private final MyList<T> tail;
	public MyLinkedList(T head, MyList<T> tail) {
		this.head = head;
		this.tail = tail;
	}

	public T head() {
		return head;
	}

	public MyList<T> tail() {
		return tail;
	}
	
	public boolean isEmpty() {
		return false;
	}
}

class Empty<T> implements MyList<T> {
	public T head() {
		throw new UnsupportedOperationException();
	}
	
	public MyList<T> tail() {
		throw new UnsupportedOperationException();
	}
}

```

다음처럼 MyLinkedList 값을 만들 수 있다.	
(이건 게으른 리스트가 아니기 때문에 5, 10이 이미 리스트에 연결되어 저장되어 있다. 추가적인 tail을 요청해도 값이 없기 때문에 더 이상 값을 생성할 수 없다.)

MyList<Integer> l = new MyLinkedList<>(5, new MyLinkedList<>(10, new Empty<>()));

head  = { 5 } , tail  = { 10, empty }

head = { 10 }, tail = { empty }


####기본적인 게으른 리스트

3장에서 배운 Supplier<T>를 이용해서 게으른 리스트를 만들면 꼬리가 모두 메모리에 존재하지 않게 할 수 있다(Supplier<T>를 void -> T라는 함수형 디스크립터를 가진 팩토리로 생각할 수 있다). Supplier<T>로 리스트의 다음 노드를 생성할 것이다.

게으른 리스트를 만드는 코드

```java
import java.util.function.Supplier;

class LazyList<T> implements MyList<T> {
	final T head;
	final Supplier<MyList<T>> tail;
	public LazyList(T head, Supplier<MyList<T>> tail) {
		this.head = head;
		this.tail = tail;
	}
	
	public T head() {
		return head;
	}
	
	public MyList<T> tail() {
		return tail.get();
	}
	public boolean isEmpty() {
		return false;
	}
}
```
(Supplier 추가했을 뿐인데 게으른 리스트가 되버리네)

이제 Supplier의 get메서드를 호출하면(마치 팩토리로 새로운 객체를 생성하듯이) LazyList의 노드가 만들어진다.
이제 연속적인 숫자의 다음 요소를 만드는 LazyList의 생성자에 tail 인수로 Supplier를 전달하는 방식으로 n으로 시작하는 무한히 게으른 리스트를 만들 수 있다.

```java
public static LazyList<Integer> from(int n) {
	return new LazyList<Integer>(n, ()-> from(n+1));
}
```

아래 코드를 실행하면 '2 3 4'라고 출력됨을 확인할 수 있다. 실제로 숫자는 요청했을 때 만들어진다.
System.out.println을 추가해서 확인할 수 있다.
만약 요청했을 때 코드가 실행되는 것이 아니라 2부터 시작해서 모든 수를 미리 계산하려 한다면 프로그램은 영원히 종료되지 않을 것이다.

```java
LazyList<Integer> numbers = from(2);
int two = numbers.head();
int three = numbers.tail().head();	//이제 계속 tail에 head를 출력하면 출력이 되는 건가?
int four = numbers.tail().tail().head();	//tail을 뽑고 계속해서 head를 출력하는 연산을 해야 하는건가?

System.out.println( two + " " + three + " " + four);
```

```java
MyList<Integer> a = numbers.tail();

for (int i = 0; i < 10; i++) {	//계속해서 tail을 뽑아서 값을 출력할 수 있음.
	a = a.tail();
	int b = a.head();
	System.out.println(b);
}	
```

####소수 생성으로 돌아와서

지금까지 만든 코드로 게으른 소수 리스트를 생성할 수 있는지 다시 한 번 확인하자(스트림 API로는 이 작업을 완료할 수 없었다)
기존에 스트림 API를 사용했던 코드에 새로운 LazyList를 적용하자.

```java
public static MyList<Integer> primes(MyList<Integer> numbers) {
	return new LazyList<>(
		numbers.head(),
		() -> primes(
			numbers.tail()
				.filter(n -> n % numbers.head() != 0)
		)
	);
}
```

####게으른 필터 구현

안타깝게도 LazyList(엄밀히 말해 List 인터페이스)는 filter메서드를 정의하지 않으므로 위 코드는 컴파일 에러가 발생한다! 이 문제를 해결하자.

```java
public MyList<T> filter(Predicate<T> p) {
	return isEmpty() ?
		this :
		p.test(head()) ?
			new LazyList<>(head(), () -> tail().filter(p)) :
			tail().filter(p);
}

```

이제 코드를 컴파일 할 수 있다. tail과 head호출을 연결해서 처음 세 개의 소수를 계산할 수 있다.


```java
LazyList<Integer> numbers = from(2);
int two = primes(numbers).head();
int three = primes(numbers).tail().head();
int five = primes(numbers).tail().tail.head();

System.out.println(two + " " + three + " " + five);
```
(그래서 이 게으른 리스트를 왜 사용했던 거더라?)

위 코드를 실행하면 '2 3 5' 세 개의 소수를 출력한다. 이제 이 코드로 좀 더 다양한 시도를 해볼 수 있다.
예를 들어 모든 소수를 출력해볼 수 있다(프로그램은 반복적으로 리스트의 머리와 꼬리를 출력하면서 printAll 메서드를 무한으로 실행할 것이다.)

```java
static <T> void printAll(MyList<T> list) {
	while (!list.isEmpty()) {
		System.out.println(list.head());
		list = list.tail();
	}
}
printAll(primes(from(2)));
```

이 장에서는 함수형 프로그래밍을 설명하고 있으므로 다음처럼 재귀적으로 문제를 깔끔히 해결할 수 있다.

```java
static <T> void printAll(MyList<T> list) {
	if (list.isEmpty()) return;
	System.out.println(list.head());
	printAll(list.tail());
}
```

그런데 위 코드는 생각처럼 무한히 실행되지 않는다. 자바는 꼬리 호출 제거를 지원하지 않으므로 스택오버 플로가 발생한다.

####드디어 완성!

지금까지 게으른 리스트와 함수를 만들었고 모든 소수를 포함하는 자료구조를 정의했다.
그런데 지금까지 만든 자료구조가 어떤 유용성을 제공하는 걸까?
(나도 이게 궁금하다 왜 필요한걸까? 알려주시라요!)
여러분은 자바8 덕분에 함수를 자료구조 내부로 추가할 수 있다는 사실을 알았고, 이런 함수는 자료구조를 만든 시점이 아니라 요청 시점에 실행된다는 사실도 확인했다. 
체스 같은 게임 프로그램 구현할 때도 이런 기능을 활용할 수 있다.
체스의 말이 움직일 수 있는 모든 가능성을 개념적으로 표현하는 트리 자료구조(즉, 미리 계산하기에는 너무 큰 자료구조)를 준비하고 요청할 때만 이 자료구조를 생성할 수 있다.
게으른 리스트는 또한 자바8의 기능 스트림과의 연결고리를 제공한다.
이제 게으른 리스트와 스트림의 장점과 단점을 살펴볼 수 있다.

아직까지 성능은 살펴보지 않았다.
지금까지 적극적으로 기능을 실행해보는 것보다 게을느 편이 좋다고 가정했다.(왜??)
물론 전통적인 실행 방법에서처럼 모든 값을 계산하는 것보단 요청했을 때 계산하는 것이 여러 면에서 좋다.
안타깝게도 현실에서는 상황이 이처럼 단순하지 않다.
자료구조의 10퍼센트 미만의 데이터만 활용하는 상황에서는 게으른 실행으로 인한 오버헤드가 더 커질 수 있다.(왜?? 뭔말이여 대체)
결정적으로 LazyList값이 진짜로 게으르지 않을 수 있다.(이것도 궁금했음 진짠지 아닌지 나야 모르니까 확인 전까지...책에서 그렇다고 해서 그런가 보다 하고 넘어가고 있었음. 알아서 찝어주니 고맙네)
from(2)등으로 LazyList값을 탐색할 때 10번째 항목까지는 모든 노드를 두 번 생성하므로 10개가 아니라 20개의 노드가 생성된다. 이 작업은 게으르게 처리할 수 없다. 
LazyList탐색을 요청할 때마다 tail의 Supplier가 반복적으로 호출된다는 점이 문제다.
처음 탐색 요청을 호출할 때만 tail의 Supplier가 호출되도록 하여(그리고 결과값을 캐시해서) 이 문제를 해결할 수 있다. 
LazyList에 private Optional<LazyList<T>> alreadyComputed 필드를 추가하고 tail메서드가 적절하게 리스트를 업데이트하도록 정리할 수 있다.
순수 함수형 언어 하스켈은 이와 같은 방식으로 자신의 자료구조를 적당히 게으르게 정리한다.
하스켈의 처리 방식에 관심이 있다면 인터넷에 다양한 기사가 있으니 살펴봐라.
(적당히 게으르게?? 적당히에 대한 로직이 들어있나보네)

게으른 자료구조는 강력한 프로그래밍 도구라는 사실을 기억하자.
애플리케이션을 구현하는 데 도움을 준다면 게으른 자료구조를 사용하자.
하지만 그로 인해 효율성이 떨어진다면 전통적인 방식으로 구현하자.
(트레이드 오프를 고려하자)

이제 거의 모든 함수형 프로그래밍 언어에서는 제공하지만 자바에선 지원하지 않는 기능인 패턴 매칭을 살펴보자.


###패턴 매칭

일반적으로 함수형 프로그래밍을 구분하는 또 하나의 중요한 특징으로 (구조적인) 패턴 매칭을 들 수 있다(정규표현식 그리고 정규표현식과 관련된 패턴 매칭과는 다르다.)
1장에선 수학에서는 다음과 같은 정의를 할 수 있다고 설명했다.

f(0) = 1
f(n) = n * f(n-1) 그렇지 않으면
(?여기서 그렇지 않으면이 저기 써있는 이유를 잘 모르겠음. 번역이 잘못된 건가? 결국에 조건문을 통해 처리를 해준다는 거 같긴 함)

반면 자바에서는 if-then-else나 switch문을 사용해야 한다.
자료형이 복잡해지면서 이러한 작업을 처리하는 데 필요한 코드(그리고 관련 잡동사니)의 양도 증가했다.
패턴 매칭을 사용하면 이러한 것들을 줄일 수 있다.

트리 탐색 예제로 이 문제를 살펴보자.
숫자와 바이너리 연산자로 구성된 간단한 수학언어가 있다고 가정하자.

class Expr { ... }
class Number extends Expr { int val; ... }
class BinOp extends Expr { String opname; Expr left, right; ... }

표현식을 단순화하는 메서드를 구현해야 한다고 하자. 예를 들어 5 + 0은 5로 단순화할 수 있다.
즉, new BinOp("+", new Number(5), new Number(0))은 Number(5)로 단순화할 수 있다.
Expr 구조체를 다음처럼 탐색할 수 있다.
(5 + 0은 5와 같기 때문에 그냥 5로 표현하자 같은 소리 같음)

```java
Expr simplifyExpression(Expr expr) {
	if(expr instanceof BinOp
		&& ((BinOp)expr).opname.equals("+"))
		&& ((BinOp)expr).right instanceof Number
		&& ... //코드가 깔끔하지 못함.
		&& ... ) {
		return (Binop)expr.left;
	}
	...
}
```
코드가 매끄럽지 않다.
(?난 잘 모르겠다 뭐가 매끄럽지 않은 건지 그냥 &&가 많이 들어간다는 뜻인가?)

####방문자 디자인 패턴

자바에선 방문자 디자인 패턴으로 자료형을 언랩할 수 있다.
특히 특정 데이터 형식을 '방문'하는 알고리즘을 캡슐화하는 클래스를 따로 만들 수 있다.
(?특정 연산자를 언랩해서 상위 표현식 클래스로 올릴 수 있다는 것 같음. 로직하나에 )
방문자 패턴은 어떻게 동작하는가?
방문자 클래스는 지정된 데이터 형식의 인스턴스를 입력으로 받는다.
그리고 인스턴스의 모든 멤버에 접근한다.
방문자 패턴은 다음과 같이 작동한다.
우선 SimplifyExprVisitor를 인수로 받는 accept를 BinOp에 추가한 다음에 BinOp 자신을 SimplifyExprVisitor로 전달한다(Number에서 비슷한 메서드를 추가한다.)

```java
class BinOp extends Expr {
	...
	public Expr accept(SimplifyExprVisitor v) {
		return v.visit(this);
	}
}
```

이제 SimplifyExprVisitor는 BinOp 객체를 언랩할 수 있다.

```java
public class SimplifyExprVisitor {
	...
	public Expr visit(BinOp e) {
		if("+".equals(e.opname) && e.right instanceof Number && ...) {
			return e.left;
		}
	}
}
```

####패턴 매칭의 힘

패턴 매칭이라는 좀 더 단순한 해결 방법도 있다.(자바에서 지원하지 않음)
자바는 패턴 매칭을 지원하지 않으므로 스칼라 프로그래밍 언어로 패턴 매칭이 뭔지 보여주려 한다.
자바에서 패턴 매칭을 지원했다면 어떤 방식으로 문제를 해결했을지 유추할 수 있을 것이다.

수식을 표현하는 Expr이라는 자료형이 주어졌을 때 스칼라 프로그래밍 언어로는 다음처럼 수식을 분해하는 코드를 구현할 수 있다(자바와 문법이 가장 비슷)

```scala
def simplifyExpression(expr: Expr): Expr = expr match{
	case BinOp("+", e, Number(0)) => e	// 0 더하기 = 의미없는 연산
	case BinOp("*", e, Number(1)) => e	// 1 곱하기 = 의미없는 연산
	case BinOp("/", e, Number(1)) => e	// 1 나누기 = 의미없는 연산
	case _ => expr				// expr을 단순화할 수 없다.
}
```

트리와 비슷한 자료구조를 다룰 때 이와 같은 패턴 매칭을 사용하면 매우 간결하고 명확한 코드를 구현할 수 있다.
특히 컴파일러를 만들거나 비즈니스 규칙 처리 엔진을 만들 때 유용하다.

```scala
Expression match { case Pattern => Expression ... }
```

위 스칼라 문법은 자바 문법과 비슷하다.

```java
switch (Expression) { case Constant : Statement ... }
```

스칼라의 와일드카드 case는 자바의 default:와 같은 역할을 한다.
(?자바의 default: 가 무슨 뜻인데? switch-case문의 default: 같은 건가?)
스칼라와 자바의 가장 큰 구문론적 차이는 스칼라가 표현지향인 반면 자바는 구문지향이라는 점이다.
프로그래머의 관점에서 느끼는 차이점은 자바의 case 패턴에서는 몇 가지 기본형, 열거형, 기본형을 감싼 특수한 클래스, 문자열 등을 사용할 수 있다는 것이다. 패턴 매칭을 지원하는 언어의 가장 큰 실용적인 장점은 아주 커다란 switch문이나 if-then-else문을 피할 수 있다는 것이다.
(조건 구문의 수가 줄어든다)

스칼라의 패턴 매칭의 쉬운 표현 방식은 자바보다 뛰어난 기능이라는 사실을 쉽게 확인할 수 있다.
그리고 자바도 좀 더 표현력 있는 switch문을 지원할 것을 기대한다.

하지만 자바8의 람다를 이용하면 패턴 매칭과 비슷한 코드를 만들 수 있다.
람다를 이와 같은 방식으로 활용할 수 있다는 사실을 보여주는 좋은 예가 될 것이다.

#####자바로 패턴 매칭 흉내 내기
(?현재 내가 이걸 알필요가 있는지는 모르겠음 아마 이걸 차라리 스칼라를 배워서 적용하는 게 빠를 수도?)
스칼라의 패턴 매칭인 match 표현식이 어떻게 동작하는지 다음 예제로 살펴보자.
```scala
def simplifyExpression(expr: Expr): Expr = expr match {
	case BinOp("+", e, Number(0)) => e
	...
```

위 코드는 expr이 BinOp인지 확인하고 expr에서 세 컴포넌트(opname, left, right)를 추출한 다음에, 이 컴포넌트에 패턴 매칭을 시도한다.
첫째는 String +, 둘째는 변수 e(항상 매치되는), 셋째는 Number(0)으로 매치한다. 즉, 스칼라(그리고 다른 많은 함수형 언어)의 패턴 매칭은 다수준(multilevel)이다.
자바8의 람다를 이용한 패턴 매칭 흉내 내기는 단일 수준의 패턴 매칭만 지원한다.
즉, 이전 예제에서 BinOp(op, l, r)이나 Number(n)은 괜찮지만 BinOp("+", e, Number(0))은 지원하지 않는다. 먼저 규칙을 정하자. 람다를 이용하며 코드에 if-then-else가 없어야 한다.
'조건 ? e1 : e2'와 메서드 호출로 if-then-else를 대신할 수 있다.

```java
myIf(condition, () -> e1, () -> e2);
```

어딘가에(아마도 라이브러리에) 다음을 정의한다(T 형식의 제네릭)

```java
static <T> T myIf(boolean b, Supplier<T> truecase, Supplier<T> falsecase) {
	return b ? truecase.get() : falsecase.get();
}
```

T 형식은 조건 표현식의 결과 형식을 의미한다. 이와 같은 기법을 if-then-else에도 적용할 수 있다.

물론 일반 코드에선 if-then-else를 사용하는 것이 코드의 명확성을 더 높일 수 있다.
하지만 자바의 switch와 if-then-else가 패턴 매칭에는 도움이 되질 않으며 람다를 이용하면 단일 수준의 패턴 매칭을 간단하게 표현할 수 있으므로 여러 개의 if-then-else 구분이 연결되는 상황을 깔끔하게 정리할 수 있다.

BinOp와 Number 두 서브클래스를 포함하는 Expr 클래스의 패턴 매칭값으로 돌아와서 patternMatchExpr이라는 메서드를 정의할 수 있다(여기서도 제네릭 T는 패턴 매칭의 결과 형식이다)

```java
interface TriFunction<S, T, U, R> {
	R apply(S s, T t, U u);
}

static <T> T patternMatchExpr(
	Expr e,
	TriFunction<String, Expr, Expr, T> binopcase,
	Function<Integer, T> numcase,
	Supplier<T> defaultcase) {
	return (e instanceof BinOp) ?
		binopcase.apply(((BinOp)e).opname, ((BinOp)e).left, ((BinOp)e).right) :
		(e instanceof Number) ?
		numcase.apply(((Number)e).val) : defaultcase.get();
}
```

다음 코드를 살펴보자.
```
patternMatchExpr(e, (op, l, r) -> { return binopcode; },
		(n) -> { return numcode; },
		() -> { return defaultcode; });
```

위 코드는 e가 BinOp인지 (BinOp라면 식별자 op, l, r로 BinOp에 접근할 수 있는 binopcode를 실행) 아니면 Number인지 (Number라면 n값에 접근할 수 있는 numcode를 실행) 확인한다.
이 메서드에는 BinOp나 Number가 아닌 트리 노드를 생성했을 때 실행되는 defaultcode도 존재한다.

다음 예제는 patternMatchExpr을 이용해서 덧셈과 곱셈 표현식을 단순화하는 방법을 보여준다.

```java
public static Expr simplify(Expr e) {
	TriFunction<String, Expr, Expr, Expr> binopcase = //BinOp 표현식 처리
		(opname, left, right) -> {
			if("+".equals(opname)) {
				if(left instanceof Number && ((Number) left).val == 0) {
					return right;
				}
				if(right instanceof Number && ((Number) right).val == 0) {
					return left;
				}
			}
			if("*".equals(opname)) {  //곱셈처리
				if(left instanceof Number && ((Number) left).val == 1) {
					return right;
				}
				if(right instanceof Number && ((Number) right).val == 1) {
					return left;
				}
			}
			return new BinOp(opname, left, right);
		};
	Function<Integer, Expr> numcase = val -> new Number(val);  //숫자처리
	Supplier<Expr> defaultcase = () -> new Number(0);  //수식을 인식할 수 없을 때 기본 처리
	return patternMatchExpr(e, binopcase, numcase, defaultcase);
}
```

다음처럼 simplify 메서드를 호출할 수 있다.

```java
Expr e = new BinOp("+", new Number(5), new Number(0));
Expr match = simplify(e);
System.out.println(match);	//5출력
```

지금까지 고차원 함수, 커링, 영속 자료구조, 게으른 리스트, 패턴 매칭 등 많은 정보를 살펴봤다.
이제 지금까지 다루지 않은 좀 더 중요하고 복잡한 정보를 살펴보자.


###기타 정보

이 절에선 함수형 그리고 참조 투명성이라는 특성과 관련된 두 가지 세부 주제를 살펴볼 것이다.
하나는 효율성과 관련된 것이고 다른 하나는 같은 결과를 반환하는 것과 관련된 염려사항이다.
두 가지 모두 흥미로운 주제지만 개념적으로 핵심적인 내용은 아니어서 이렇게 마지막 부분에서 다룬다.
또한 두 개 이상의 함수를 인수로 받아서 다른 함수를 반환하는 메서드나 함수를 가리키는 콤비네이터의 개념도 살펴본다.
콤비네이터는 자바8 API에 여러 기능을 추가하도록 영감을 준 기능이다.

####캐싱 또는 기억화

트리 형식의 토포로지(topology, 노드나 링크가 연결된 것을 말함)를 갖는 네트워크 범위 내에 존재하는 노드의 수를 계산하는 computeNumberOfNodes(Range)라는 부작용 없는 메서드가 있다고 가정하자.
다행히 네트워크는 불변(즉, 구조가 변하지 않음)이지만 computeNumberOfNodes를 호출했을 때 구조체를 재귀적으로 탐색해야 하므로 노드 계산 비용이 비싸다. (?구조체를 재귀적으로 탐색하므로 메모리 비용이 높단 뜻인가?)
게다가 이와 같은 계산을 반복해서 수행해야 할 것 같다.
이때 참조 투명성이 유지되는 상황이라면 간단하게 추가 오버헤드를 피할 수 있는 방법이 생긴다.
표준적인 해결책으로 기억화(memorization, 아마 피보나치 재귀에서 사용하는 기법을 말하는 듯)라는 기법이 있다.
기억화는 메서드에 래퍼로 캐시(HashMap 같은)를 추가하는 기법이다.
래퍼가 호출되면 인수, 결과 쌍이 캐시에 존재하는지 먼저 확인한다.
캐시에 값이 존재하면 캐시에 저장된 값을 즉시 반환한다.
캐시에 값이 없다면 computeNumberOfNodes를 호출해서 결과를 계산한 다음 새로운 인수, 결과 쌍을 캐시에 저장하고 결과를 반환한다.
엄밀히 따져서 캐싱, 즉 다수의 호출자가 공유하는 자료구조를 갱신하는 기법이므로 이는 순수 함수형 해결방식은 아니지만 감싼 버전의 코드는 참조 투명성을 유지할 수 있다.
(?감싼 버전의 코드가 뭐지?)

다음은 캐싱을 사용하는 예제 코드다.

```java
final Map<Range, Integer> numberOfNodes = new HashMap<>();	//final로 외부에 선언
Integer computeNumberOfNodesUsingCache(Range range) {	//외부에 있는 걸 함수형에서 사용할 수 있나? 문제 없나 노드가 불변이라? 어차피 계산된 결과를 찾아서 사용하기가 전부라 의미 없는 듯? 
	Integer result = nubmerOfNodes.get(range) {
	if(result != null) {
		return result;
	}
	result = computeNumberOfNodes(range);
	numberOfNodes.put(range, result);
	return result;
}
```

NOTE_ 아래 예제에서 볼 수 있는 것처럼 자바8에서는 computeIfAbsent라는 유용한 메서드를 Map 인터페이스에 추가했다. 자바8에서 추가된 메서드는 부록B에서 확인할 수 있다. 메서드 computeIfAbsent를 사용하면 좀 더 명료하게 코드를 구현할 수 있다.(?재귀를 사용한다면 Map캐싱을 자주 쓸 일이 많아서 Map에 아싸리 추가한 듯?)

```java
Integer computeNumberOfNodesUsingCache(Range range) {
	return numberOfNodes.computeIfAbsent(range, this::computeNumberOfNodes);
}
```

메서드 computeNumberOfNodesUsingCache는 참조투명성을 갖는다(computeNumberOfNodes도 참조 투명하다는 가정하에).
하지만 numberOfNodes는 공유된 가변 상태며 HashMap은 동기화되지 않았으므로 스레드 안전성이 없는 코드다.
(?위에서 내가 궁금했던 내용이네)
HashMap 대신 잠금으로 보호되는 HashTable이나 잠금 없이 동시 실행을 지원하는 ConcurrentHashMap을 사용할 수 있지만 다중 코어에서 numberOfNodes를 동시에 호출하면 성능이 크게 저하될 수 있다.
(?솔직히 HashTable과 ConcurrentHashMap을 사용해 본 적이 없어서 어떤 장단점이 있는 자료구존지 모르겠음 한 번 찾아봐야겠음 나중에) 
(?동기화를 한다는 것은 lock을 건다는 거기 때문에 성능저하가 발생할 것 같음)
이는 맵에 range가 있는지 찾는 과정과 인수, 결과 쌍을 맵에 추가하는 동작 사이에서 레이스 컨디션이 발생하기 때문이다.
즉, 여러 프로세스가 같은 값을 맵에 추가하기 위해 여러 번 계산하는 일이 발생할 수 있다.
가장 좋은 방법은 함수형 프로그래밍을 사용해서 동시성과 가변 상태가 만나는 상황을 완전히 없애는 것이다.
하지만 캐싱 같은 저수준 성능 문제는 해결되지 않는다.
캐싱을 구현할 것인지 여부와는 별개로 코드를 함수형으로 구현했다면 우리가 호출하려는 메서드가 공유된 가변 상태를 포함하지 않음을 미리 알 수 있으므로 동기화 등을 신경 쓸 필요가 없어진다.

####'같은 객체를 반환함'은 무엇을 의미하는가?

이전 이진트리 예제를 다시 살펴보자.
변수 t는 기존 트리를 가리키는데 fupdate("Will", 26, t)를 호출하면 새로운 트리가 생성되고 변수 t2로 할당되는 부작용을 보여준다.
t 그리고 t에서 접근할 수 있는 모든 자료구조는 변하지 않았다는 사실을 명확히 보여준다.

t3 = fupdate("Will", 26, t);

이번에는 t2 대신 t3라는 변수가 새로 생성된 세 개의 노드를 가리킨다.
'fupdate는 참조 투명성을 갖는가?'라는 의문이 생긴다.
참조투명성이란 '인수가 같다면 결과도 같아야 한다'라는 규칙을 만족함을 의미한다.
여기서 t2와 t3은 서로 다른 참조다.
즉, (t2 == t3)을 만족하지 않으므로 fupdate는 참조투명성을 갖지 않는다고 결론내릴 수 있다.
그러나 자료구조를 변경하지 않는 상황에서 참조가 다르다는 것은 큰 의미가 없으며 t2와 t3이 논리적으로 같다고 판단할 수 있다.
(?이게 먼말이지?? 변수t2,t3만 다를 뿐 참조하는 값은 같다는 건가?)
참조 투명성이냐 아니냐를 토론하자면 얘기가 아주 길어진다.
일반적으로 함수형 프로그래밍에서는 데이터가 변경되지 않으므로 같다는 의미는 ==(참조가 같음)이 아니라 구조적인 값이 같다는 것을 의미한다.
따라서 함수형 프로그래밍 관점에서 fupdate는 참조 투명성을 갖는다고 말할 수 있다.


####콤비네이터

함수형 프로그래밍에선 두 함수를 인수로 받아 다른 함수를 반환하는 등 함수를 조합하는 고차원함수를 많이 사용하게 된다.
이처럼 함수를 조합하는 기능은 콤비네이터라고 부른다.
자바8 API에 추가된 많은 기능은 콤비네이터의 영향을 받았다.
(?이런 내용을 알고 글을 쓰려면 함수형 프로그래밍을 먼저 공부했고 이후 자바8 API를 공부했어야 가능할 듯)
예를 들어 CompletableFuture 클래스에는 thenCombine이라는 메서드가 추가되었다.
thenCombine메서드는 CompletableFuture와 BiFunction 두 인수를 받아 새로운 CompletableFuture를 생성한다.
함수형 프로그래밍의 콤비네이터를 자세히 살펴보진 않을 것이다.
하지만 몇 가지 예제를 통해 함수를 인수로 받아서 또 다른 함수를 반환하는 동작이 함수형 프로그래밍에서 얼마나 흔하고, 자연스러운 일인지 확인할 수 있다.
다음은 함수조합이라는 개념을 보여주는 코드다.

```java
static <A, B, C> Function<A, C> compose(Function<B, C> g, Function<A, B> f) {
	return x -> g.apply(f.apply(x));
}
```

compose 함수는 f와 g를 인수로 받아서 f의 기능을 적용한 다음에 g의 기능을 적용하는 함수를 반환한다.
이 함수를 활용하면 콤비네이터로 내부 반복을 수행하는 동작을 정의할 수 있다.
데이터를 받아서 f에 연속적으로 n번 적용하는 루프가 있다고 가정하자.
이 함수의 이름은 repeat로 f라는 함수를 인수로 받는다.

repeat(3, (Integer x) -> 2*x);

위 코드를 실행하면 x -> (2*(2*(2*x))) 또는 x -> 8*x 라는 결과가 나온다.

다음 코드로 결과를 확인할 수 있다.

코드를 실행하면 80이 출력된다.

System.out.println(repeat(3, (Integer x) -> 2*x).apply(10));

repeat 메서드를 다음처럼 구현할 수 있다(루프를 한 번도 돌지 않는 상황은 예외적으로 처리함)

```java
static <A> Function<A,A> repeat(int n, Function<A,A> f) {
	return n==0 ? x -> x	//n이 0이면 아무것도 하지 않는 함수를 반환
		: compose(f, repeat(n-1, f));	//n이 0이 아니면 재귀적으로 compose를 반환)
}
```

이 개념을 활용하면 반복 과정에서 전달되는 가변 상태 함수형 모델 등 반복 기능을 좀 더 다양하게 활용할 수 있다.
이 장에서는 자바8에서 제공하는 함수형 프로그래밍을 전체적으로 소개했다.
이것으로 함수형 프로그래밍에 대한 설명을 마친다.













