# 함수형 관점으로 생각하기

함수형(functional)은 일급함수와 관련이 있으며 때로는 객체 변화를 제한하는 것이 함수형과 밀접한 관련을 갖는다.

*** 함수형을 적용하면 어떤 점이 좋을까? ***


### 시스템 구현과 유지보수

누군가 우리에게 이미 구현되어 있지만 실제 경험해본 적은 없는 대규모 소프트웨어 시스템 업그레이드 관리를 요청했다고 가정하자.

이 요청을 받아들일 것인가?

'먼저 프로그램 내에 synchronized가 없다면 시스템의 구조를 자세히 검토해보라'-자바 개발자사이의 풍문이 떠돈다.

지금까지는 자바8의 스트림을 이용하면 잠금(locking)문제를 신경 쓰지 않을 수 있었다. 단, 자바8의 스트림을 이용하려면 상태 없는 동작이어야 한다는 조건을 만족해야 한다(즉, 스트림 처리 파이프라인의 함수는 다른 누군가가 변수의 값을 바꿀 수 있는 상태에 있는 변수-외부변수-를 사용하지 않는다.)
또한 쉽게 유지보수할 수 있으려면 프로그램이 어떤 모습이어야 할까? 프로그램이 시스템의 구조를 이해하기 쉽게 클래스 계층으로 반영한다면 좋을 것이다.
결합도(coupling)와 응집도(cohesion)라는 소프트웨어 엔지니어링 도구로 프로그램 구조를 평가할 수 있다.

그러나 실질적으로 많은 프로그래머가 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게 된다.
코드 크래시는 예상하지 못한 변숫값 때문에 발생할 수 있다.
왜 그리고 어떻게 변숫값이 바뀐 걸까?
유지보수 중 이런 일이 얼마나 자주 일어나는지 생각해보라.
함수형 프로그래밍이 제공하는 부작용 없음과 불변성이라는 개념이 이 문제를 해결하는 데 도움을 준다.

#### 공유된 가변 데이터

변수가 예상하지 못한 값을 갖는 이유는? 시스템의 여러 곳에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다. (DB처럼, 따라서 locking이 중요하다. 하지만 locking은 병목현상을 발생시킬 수 있다.)
리스트를 참조하는 여러 클래스가 있다고 가정하자.
리스트의 소유자는 어느 클래스인가?
이들 중 하나의 클래스가 리스트를 갱신하면 어떻게 될까?
다른 클래스는 리스트가 갱신되었다는 사실을 알고 있을까?
다른 클래스에 리스트가 갱신되었음을 어떻게 알려줄 수 있을까?
리스트 갱신 사실을 알리는 것이 좋을까 아니면 안전하게 리스트 사본을 만드는 것이 나을까?

이처럼 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.

어떤 자료구조도 바꾸지 않는 시스템이 있다고 가정하자.
예상하지 못하게 자료구조의 값이 바뀔 일이 없으니 얼마나 유지보수하기 쉽겠는가?!
자신을 포함하는 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수(pure)메서드 또는 부작용 없는(side-effect free)메서드 라고 부른다.

구체적으로 부작용은 무엇일까? 함수 내에 포함되지 못한 기능을 부작용이라고 한다.
- 자료구조를 고치거나 필드에 값을 할당(setter 메서드 같은 생성자 이외의 초기화 동작)
- 예외 발생
- 파일에 쓰기 등의 I/O 동작 수행

이러한 부작용은 불변객체를 이용해서 없앨 수도 있다. 불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않는다. 즉, 인스턴스화한 불변 객체의 상태는 결코 예상하지 못한 상태로 바뀌지 않는다.(그러면 해당 객체의 변경된 값을 사용하려면 항상 복사본을 사용해서 값을 사용해야 하는 건가?)
따라서 불변 객체는 복사하지 않고 공유할 수 있으며, 객체의 상태를 바꿀 수 없으므로 스레드 안전성을 제공한다.

어떤 사람은 실제 시스템에서 부작용을 없앤다는 것이 현실적으로 가능한지 의아해 할 수 있다. 
이 책을 읽고 부작용을 없앨 수 있다는 사실을 확신하기 바란다.
부작용 없는 시스템 컴포넌트에서는 메서드가 서로 간섭하는 일이 없으므로 잠금을 사용하지 않고도(병목없이) 멀티코어 병렬성을 사용할 수 있다. 또한 프로그램의 어떤 부분이 독립적인지 바로 이해할 수 있다.

부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래되었다.
함수형 프로그래밍의 기반을 이루는 개념인 선언형 프로그래밍을 살펴보자.(스트림에서 사용했던 내용인 듯)


#### 선언형 프로그래밍

프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있다. '이 일을 먼저하고, 그다음에 저 값을 갱신하고, 그다음에...' 처럼 작업을 어떻게 수행할 것인지에 집중하는 방법이 있다.
이처럼 '어떻게'에 집중하는 프로그래밍 형식은 고전의 객체지향 프로그래밍에서 이용하는 방식이다.
때로는 이를 명령형 프로그래밍이라고 부르기도 하는데 다음 코드에서 보여주는 것처럼 (할당, 조건문, 분기문, 루프 등) 명령어가 컴퓨터의 저수준 언어와 비슷하게 생겼기 때문이다.

```java
Transaction mostExpensive = transaction.get(0);
if(mostExpensive == null)
	throw new IllegalArgumentException("Empty list of transactions")

for (Transaction t: transactions.subList(1, transactions.size())) {
	if (t.getValue() > mostException.getValue()) {
		mostExpensive = t;
	}
}
```

'어떻게'가 아닌 '무엇을'에 집중하는 방식도 있다.
이전 스트림 API로 다음과 같은 질의를 만들 수 있었다.

```java
Optional<Transaction> mostExpensive = 
	transactions.stream()
		.max(comparing(Transaction::getValue));
```

질의문 구현 방법은 라이브러리가 결정한다. 이와 같은 구현 방식을 *** 내부 반복*** 이라고 한다.
질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다.

이처럼 '무엇을'에 집중하는 방식을 선언형 프로그래밍이라고 부른다. 
선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성한 것인지 등의 규칙을 정한다. 문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점이다.


#### 왜 함수형 프로그래밍인가?

함수형은 선언형을 따르는 대표적인 방식이며, 부작용이 없는 계산을 지향한다. 
위 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.

람다 표현식을 통해서 작업을 조합하거나 동작을 전달하는 등의 언어기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현하는데 많은 도움을 준다.
스트림으론 여러 연산을 연결해서 복잡한 질의를 표현할 수 있었다.

실제로 함수형 프로그래밍을 사용하고 자바8의 새로운 기능과 연결하려면 먼저 함수형 프로그래밍을 제대로 정의하고 자바로 어떻게 구현하는지 살펴봐야 한다. 함수형 프로그래밍을 이용하면 부작용이 없는 복잡하고 어려운 기능을 수행하는 프로그램을 구현할 수 있다.


### 함수형 프로그래밍이란 무엇인가?

'함수를 이용하는 프로그래밍이다'라고 답할 수 있다. 그럼 '함수란 무엇인가?'라는 질문이 다시 꼬리를 문다.

int와 double을 인수로 받아서 double을 반환하는 메서드가 있는데 이 메서드는 자신이 호출된 횟수로 가변 변수를 갱신하는 부작용을 포함하고 있다.

함수형 프로그래밍에서 함수란 수학적인 함수와 같다. 즉, 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 부작용이 없어야 한다. 
(side-effect없이 입력에 따른 출력만 수행, 동일한 입력에 대해서 동일한 출력을 반환, 솔직히 자바를 통한 복잡한 프로그래밍을 해보지 않아서 함수형 프로그래밍의 필요성을 충분히 인지하지 못한 상태로 이 책을 읽는 것에 대해서 아쉬움이 있다.)

자바와 같은 언어에서는 바로 수학적인 함수냐 아니냐가 메서드와 함수를 구분하는 핵심이다.
(log, sin 등의 수학적 함수는 절대 부작용을 포함하지 않을 것이다.)

***함수형***프로그래밍은 지금까지의 프로그래밍과는 사뭇 다른 모습일 것이다.
함수형 프로그래밍에선 함수 그리고 if-then-else등의 수학적 표현만 사용해야 하는가? 
아니면 시스템의 다른 부분에 ***영향을 미치지 않는다면*** 내부적으로 함수형이 아닌 기능도 사용할 수 있을까?
즉, 내부적으론 부작용이 발생하지만 호출자가 이를 알아차리지 못한다면 실제로 부작용이 발생한 것이라고 말할 수 있을까? 호출자에게 아무 영향을 미치지 않는다면 호출자는 내부적인 부작용을 파악하거나 신경쓸 필요가 없다.
결론적으로 '함수 그리고 if-then-else 등의 수학적 표현만 사용'하는 방식을 순수 함수형 프로그래밍이라고 하며 '시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용'하는 방식을 함수형 프로그래밍이라 한다.


#### 함수형 자바

실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 예를 들어 자바의 I/O 모델 자체에는 부작용 메서드가 포함된다(Scanner.nextLine을 호출하면 파일의 행을 소비한다. 즉, Scanner.nextLine을 두 번 호출하면 다른 결과가 반환될 가능성이 있다.)
하지만 시스템의 컴포넌트가 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수 있다.
자바에선 순수 함수형이 아니라 ***함수형 프로그래밍***을 구현할 것이다.
실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 함수형을 달성할 수 있다.
예를 들어 부작용을 일으키는 어떤 함수나 메서드가 있는데, 다만 진입할 때 어떤 필드의 값을 증가시켰다가 빠져나올 때 필드의 값을 돌려놓는다고 가정하자. 단일 스레드로 실행되는 프로그램의 입장에서는 이 메서드가 아무 부작용을 일으키지 않으므로 이 메서드는 함수형이라 간주할 수 있다. 하지만 다른 스레드가 필드의 값을 확인한다든가 아니면 동시에 이 메서드를 호출하는 상황이 발생할 수 있다면 이 메서드는 함수형이 아니다. 메서드의 바디를 잠금으로써 이 문제를 해결할 수 있으며 따라서 이 메서드는 함수형이라고 할 수 있다.
하지만 이런 식의 해결은 멀티코어 프로세서에서 메서드를 병렬로 호출할 수 없게 된다.
결국 부작용은 사라지지만 실행속도가 느려진다.

함수나 메서드는 ***지역 변수만***을 변경해야 함수형이라고 할 수 있다.
그리고 함수나 메서드에서 참조하는 객체가 있다면 불변 객체여야 한다.
예외적으로 메서드 내에서 생성한 객체의 필드는 갱신할 수 있다.
단 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 하고, 다음에 메서드를 다시 호출할 때 영향을 미치면 안된다.

함수형이라고 말할 수 있으려면 이 외에도 다른 조건을 만족해야 한다. 함수형이라면 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.
예외가 발생하면 return으로 결과 반환이 안되기 때문이다.
이러한 제약은 Optional을 통해 해결할 수 있다.
예외 없이도 결과값으로 연산을 성공적으로 수행했는지 아니면 요청된 연산을 성공적으로 수행하지 못했는지 확인할 수 있다.
즉, 호출자는 메서드 호출결과로 빈 Optional이 반환되는지 확인해야 한다.
이는 상당히 귀찮은 작업같다.
하지만 모든 코드가 Optional을 사용하도록 반드시 고쳐야 하는 것은 아니다.
함수형 프로그래밍과 순수 함수형 프로그래밍의 장단점을 실용적으로 고려해서 다른 컴포넌트에 영향을 미치지 않도록 지역적으로만 예외를 사용하는 방법도 고려할 수 있다.

함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.(즉, 먼저 자료구조를 복사한다든가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야 한다.)
이와 같은 설명을 주석으로 표현하거나 마커 어노테이션으로 메서드를 정의할 수 있다.
마커 어노테이션을 사용했다면 4장부터 7장까지 살벼본 Stream.map같은 병렬 스트림 처리 연산에 전달할 때 이와 같은 제약이 있는지 쉽게 확인할 수 있다.

우리가 만든 함수형 코드에서는 일종의 로그 파일로 디버깅 정보를 출력하도록 구현하는 것이 좋다.
물론 이처럼 디버깅 정보를 출력하는 것은 함수형 규칙에 위배되지만 로그 출력을 제외하고는 함수형 프로그래밍의 장점을 문제없이 누릴 수 있다.

#### 참조 투명성

'부작용을 감춰야 한다'라는 제약은 ***참조 투명성*** 개념으로 귀결된다. 즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.
("raoul".replace('r', 'R')이란 코드는 항상 같은 결과가 나오므로 String.replace는 참조적으로 투명하다. String.replace는 return this가 아니라 처리 후 새로운 String을 반환함.)

다시 말해, 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다.
따라서 Random.nextInt는 매번 다른 값이 호출되므로 함수형이 될 수 없다.
마찬가지로 Scanner객체로 사용자의 키보드 입력을 받는다면 참조 투명성을 위배한다.
nextLine 메서드를 호출했을 때 매번 다른 결과가 나올 수 있기 때문이다.
하지만 두 개의 final int변수를 더하는 연산에서는 두 변수를 바꿀 수 없으므로 이 연산은 항상 같은 결과를 생성한다.

참조 투명성은 프로그램 이해에 큰 도움을 준다. 또한 참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 기억화 또는 캐싱을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다. 이 기능이 중요하니 추후 설명한다.

자바에는 참조 투명성과 관련한 작은 문제가 있다. List를 반환하는 메서드를 두 번 호출한다고 가정하자. 두 번의 호출 결과로 같은 요소를 포함하지만 서로 다른 메모리 공간에 생성된 리스트를 참조할 것이다.
(각 List는 필드들은 같지만 메모리 주소가 다른 객체이다.)
결과 리스트가 가변 객체라면 (반환된 두 리스트가 같은 객체라 할 수 없으므로) 리스트를 반환하는 메서드는 참조적으로 투명한 메서드가 아니라는 결론이 나온다. 결과 리스트를 (불변의) 순수값으로 사용할 것이라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는 참조적으로 투명한 것으로 간주할 수 있다.
일반적으로 함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다. 

#### 객체지향 프로그래밍과 함수형 프로그래밍

먼저 함수형 프로그래밍과 기존의 익스트림 객체지향 프로그래밍을 비교하자.
사실 자바8은 함수형 프로그래밍을 익스트림 객체지향 프로그래밍의 일종으로 간주한다.
대부분의 자바 프로그래머는 무의식적으로 함수형 프로그래밍의 일부 기능과 익스트림 객체지향의 일부 기능을 사용할 것이다.
1장에서 설명한 것처럼(멀티코어 등의) 하드웨어 변경과 (데이터 베이스의 질의와 비슷한 방식으로 데이터를 조작하는 등의) 프로그래머의 기대치 때문에 결국 자바 소프트웨어 엔지니어의 프로그래밍 형식이 좀 더 함수형으로 다가갈 것이다.

|익스트림 객체지향 <-----------> 함수형 프로그래밍|
위 스펙트럼에서 중간에서 프로그래밍 할 것이다.
예를 들어 Iterator로 가변 내부 상태를 포함하는 자료구조를 탐색하면서 함수형 방식으로 자료구조에 들어 있는 값의 합계를 계산할 수 있다(이미 설명했듯이 자바에서는 지역 변수 변화가 수반될 수 있다.) 
모듈성이 좋고 멀티코어 프로세서에 적합한 프로그램을 구현하는 데 도움을 주는 함수형 프로그래밍의 기능을 소개하겠다.

#### 함수형 실전 연습

함수형을 처음 접하는 학생들에게 종종 제공되는 간단한 예제를 살펴보자. {1, 4, 9}처럼 List<Integer>가 주어졌을 때 이것의 모든 서브집합의 멤버로 구성된 List<List<Integer>>를 만드는 프로그램을 만든다고 가정하자. 예를 들어 {1, 4, 9}의 서브집합은 {1, 4, 9}, {1, 4}, {1, 9}, {4, 9}, {1}, {4}, {9}, {} 다.
빈 집합{}를 포함해서 총 8개의 서브집합이 존재한다. 
보통 '{1, 4, 9}의 서브집합 중 1을 포함하는 집합과 아닌 집합'으로 구분해서 문제를 풀려 시도할 것이다.
1을 포함하지 않는 부분집합은 {4, 9}의 부분집합이고, 1을 포함하는 부분집합은 {4, 9}의 모든 부분집합에 1을 포함시켜 얻을 수 있다. 이와 같은 접근 방식은 가장 쉽고, 자연스러운 함수형 함수형 자바 프로그래밍이다(여기서 가장 많이 하는 실수는 빈 리스트는 부분집합이 없다고 착각하는 것이다)

```java
static List<List<Integer>> subsets(List<Integer> list) {
	if (list.isEmpty()) {	//List가 비어있다면 비어있는 리스트를 하나 생성하여 반환
		List<List<Integer>> ans = new ArrayList<>();
		ans.add(Collections.emptyList());
		return ans;   //빈 리스트 자신이 서브집합이다.
	}			
	Integer first = list.get(0);    //첫 요소를 꺼냄.
	List<Integer> rest = list.subList(1, List.size());   //첫 요소제외한 여분
	
	//빈 리스트가 아니면 먼저 하나의 요소를 꺼내고 나머지 요소의 모든 서브집합을 찾아서 subans로 전달. subans는 절반의 정답을 포함한다.
	List<List<Integer>> subans = subsets(rest);   //여분을 가지고 재귀 수행
	
	//정답의 나머지 절반을 포함하는 subans2는 subans의 모든 리스트에서 처음 꺼낸 요소를 앞에 추가해서 만든다.
	List<List<Integer>> subans2 = insertAll(first, subans);  //첫 요소와 재귀수행한 여분을 합침
	return concat(subans, subans2);  //둘을 합침
}
```
입력으로 {1,4,9}를 제공하면 결과로 8개의 서브집합을 얻는다.
insertAll과 concat의 구현이 없다. 직접 완성하고 실행해 보자.

insertAll을 정의해보자. 첫 번째 함정이 나타났다.
만약 여러분이 insertAll의 인수를 변환하도록, 즉 subans의 모든 요소가 first를 포함하도록 인수를 변환했다고 가정하자. 결국 subans가 의도하지 않은 값을 포함하면서 이상한 결과가 나온다. (나도 단순하게 인자로 넘어온 subans에 first를 추가했음) 
다음처럼 insertAll을 정의해야 한다.


```java
static List<List<Integer>> insertAll(int first, List<List<Integer>> subans){

        List<List<Integer>> result = new ArrayList<>();
        for (List<Integer> list : subans) {
//리스트를 복사한 다음에 복사한 리스트에 요소를 추가한다. 
//구조체가 가변이더라도 저수준 구조를 복사하진 않는다. (Integer는 가변이 아니다.)
            List<Integer> copyList = new ArrayList<>();  
            copyList.add(first);
            copyList.addAll(list);
            result.add(copyList);
        }
        System.out.println("insertAll = " + result);
        return result;
}
```
subans의 모든 요소를 포함하는 새로운 List를 만들었다는 점에 주목하라. 여기선 Integer 객체가 불변이라는 사실을 이용했다(Integer가 불변이 아니라면 각 요소를 모두 복제해야 한다)
(불변 관련 내용 참조 : https://velog.io/@urtimeislimited/Java-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%97%90%EC%84%9C%EC%9D%98-%EB%B6%88%EB%B3%80%EC%84%B1#referenece)



마지막으로 concat 메서드를 정의한다. 다음은 간단하게 concat을 구현한 코드이므로 ***실무에선 사용하지 않도록 주의하자***.

```java
static List<List<Integer>> concat(List<List<Integer>> subans, List<List<Integer>> subans2) {
        subans.addAll(subans2);

        return subans;
}
```

다음처럼 구현하는 것이 바람직하다.

```java
static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b) {
        List<List<Integer>> r = new ArrayList<>(a);
	r.addAll(b);

        return r;
}
```

왜 두 번째 버전이 더 좋은 코드일까?
두 번째 버전의 concat은 순수 함수다.

내부적으로는 리스트 r에 요소를 추가하는 변화가 발생하지만 반환 결과는 오로지 인수에 의해 이루어지며 인수의 정보는 변경하지 않는다. 이와 달리 첫 번째 버전은 concat(subans, subans2)를 호출한 다음에 subans의 값을 다시 참조하지 않는다는 가정을 한다.(먼말이죠?)
실제로 우리 예제에선 subans의 값을 다시 참조하지 않으므로 더 가벼운 버전의 concat을 사용하는 것이 바람직하다. 각자의 상황에 따라 복제하는 것이 좋을지 잠재적인 버그를 찾기 위해 시간을 소비하는 것이 비용이 적을지 고려해서 어떤 방식을 선택할지 결정할 수 있다.(??!! 당연히 복제가 아닌가?)

'메서드의 첫 번째 인수를 임의의 값으로 바꿀 수 있는 상황에서만 메서드를 사용해야 하며 subsets를 고칠 때는 이 사실을 고려해야 함' 이라는 자세한 설명을 주석으로 추가했어도 여전히 누군가가 코드를 사용할 때는 이런 사실을 고려하기보다는 애초부터 끔찍한 디버깅 문제가 발생할 가능성이 없도록 구현된 코드를 선호할 것이다.

인수에 의해 출력이 결정되는 함수형 메서드의 관점에서 프로그램 문제를 생각하자. (즉, 무엇을 해야 하는가에 중점을 둔다)
이와 같은 방식으로 문제를 접근하면 설계 단계에서 어떻게 문제를 해결할 것이고 무엇을 변화할 것인지 결정하는 기존 방식에 비해 더 생산적일 때가 많다(설계 단계는 이와 같은 결정을 내리기에 너무 이른 상황이기 때문) 무엇을 해야 하는가에 집중할 수 있도록 도움을 주는 함수형 프로그래밍의 한 기법인 재귀를 좀 더 자세히 살펴보자.

### 재귀와 반복

순수 함수형 프로그래밍 언어에선 while, for 같은 반복문을 포함하지 않는다. 왜 그럴까?
이러한 반복문 때문에 변화가 자연스럽게 코드에 스며들 수 있기 때문이다. 
함수형 스타일에서는 다른 누군가가 변화를 알아차리지만 못한다면 아무 상관이 없다고 설명했다.
즉, 지역변수는 자유롭게 갱신할 수 있다.
다음은 자바의 Iterator로 for(Apple a : apples) {}라는 for-each 루프를 표현한 코드다.

